<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UFC Live Tracker</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }


        .updating {
            animation: updating 0.5s ease;
        }

        @keyframes updating {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .stat-blue, .stat-red {
            transition: all 0.3s ease;
        }

        .prob-blue, .prob-red {
            transition: width 0.5s ease;
        }

        .live-event {
            border: 2px solid #4caf50 !important;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.3) !important;
            animation: liveGlow 2s infinite alternate;
        }

        .live-badge {
            background: linear-gradient(45deg, #4caf50, #66bb6a) !important;
            color: white !important;
            animation: pulse 2s infinite;
        }

        @keyframes liveGlow {
            from { box-shadow: 0 0 20px rgba(76, 175, 80, 0.3); }
            to { box-shadow: 0 0 30px rgba(76, 175, 80, 0.6); }
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #404040;
            border-top: 4px solid #d32f2f;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        .stat-card.live {
            border-color: #4caf50 !important;
            background: linear-gradient(145deg, #1a2e1a, #2d4a2d) !important;
        }

        .stat-card.live .icon {
            color: #4caf50 !important;
        }

        .stat-card.live h3 {
            color: #4caf50 !important;
        }

        .fighter-record {
            color: #cccccc;
            font-size: 0.9rem;
            margin-top: 0.2rem;
        }

        .fighter-nationality {
            color: #f57c00;
            font-size: 0.8rem;
            margin-top: 0.3rem;
            font-style: italic;
        }

        .fighter-weight-class {
            color: #d32f2f;
            font-size: 0.8rem;
            margin-top: 0.2rem;
            font-weight: bold;
        }

        .fight-item .fighter-record {
            color: #999;
            font-size: 0.8rem;
            margin-left: 0.5rem;
        }

        .fighters {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        @media (max-width: 768px) {
            .fighters {
                flex-direction: column;
                text-align: center;
                gap: 0.2rem;
            }

            .fighter-record {
                font-size: 0.8rem;
            }
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 50%, #2d1b2e 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Header */
        .header {
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            border-bottom: 2px solid #d32f2f;
        }

        .nav-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1.5rem;
            font-weight: bold;
            color: #d32f2f;
        }

        .ufc-logo {
            width: 40px;
            height: 24px;
            background: #d32f2f;
            position: relative;
            font-family: 'Arial Black', Arial, sans-serif;
            font-weight: 900;
            font-size: 14px;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 2px;
            letter-spacing: -1px;
        }

        .nav-menu {
            display: flex;
            list-style: none;
            gap: 2rem;
            align-items: center;
        }

        .nav-menu a {
            color: #ffffff;
            text-decoration: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .nav-menu a:hover {
            background: #d32f2f;
            transform: translateY(-2px);
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 1rem;
            font-size: 0.9rem;
        }

        .user-badge {
            background: #d32f2f;
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            font-size: 0.8rem;
        }

        /* Main Content */
        .main-content {
            margin-top: 80px;
            padding: 2rem;
            max-width: 1400px;
            margin-left: auto;
            margin-right: auto;
        }

        /* Auth Modal */
        .auth-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .auth-container {
            background: linear-gradient(145deg, #1a1f2e, #2d1b2e);
            padding: 3rem;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            width: 100%;
            max-width: 450px;
            margin: 1rem;
            border: 1px solid #d32f2f;
        }

        .auth-header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .auth-header h2 {
            color: #d32f2f;
            font-size: 2rem;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #cccccc;
            font-weight: 500;
        }

        .form-group input {
            width: 100%;
            padding: 0.8rem;
            border: 2px solid #404040;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .form-group input:focus {
            outline: none;
            border-color: #d32f2f;
            box-shadow: 0 0 10px rgba(211, 47, 47, 0.3);
        }

        .auth-button {
            width: 100%;
            padding: 1rem;
            background: linear-gradient(45deg, #d32f2f, #f57c00);
            border: none;
            border-radius: 8px;
            color: #ffffff;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 1rem;
        }

        .auth-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(211, 47, 47, 0.3);
        }

        .auth-switch {
            text-align: center;
            color: #cccccc;
        }

        .auth-switch a {
            color: #d32f2f;
            cursor: pointer;
            text-decoration: none;
        }

        /* Dashboard */
        .dashboard {
            display: none;
        }

        .dashboard.active {
            display: block;
        }

        .dashboard-header {
            text-align: center;
            margin-bottom: 3rem;
        }

        .dashboard-header h1 {
            font-size: 3rem;
            background: linear-gradient(45deg, #d32f2f, #f57c00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 1rem;
        }

        .dashboard-header p {
            font-size: 1.2rem;
            color: #cccccc;
            max-width: 600px;
            margin: 0 auto;
        }

        /* Stats Cards */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 2rem;
            margin-bottom: 3rem;
        }

        .stat-card {
            background: linear-gradient(145deg, #1a1f2e, #2d1b2e);
            padding: 2rem;
            border-radius: 15px;
            border: 1px solid #404040;
            text-align: center;
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            border-color: #d32f2f;
            box-shadow: 0 10px 30px rgba(211, 47, 47, 0.2);
        }

        .stat-card .icon {
            font-size: 3rem;
            color: #d32f2f;
            margin-bottom: 1rem;
        }

        .stat-card h3 {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .stat-card p {
            color: #cccccc;
        }

        /* Events Section */
        .events-section {
            margin-bottom: 3rem;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .section-header h2 {
            font-size: 2rem;
            color: #d32f2f;
        }

        .btn {
            padding: 0.8rem 1.5rem;
            background: linear-gradient(45deg, #d32f2f, #f57c00);
            border: none;
            border-radius: 8px;
            color: #ffffff;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(211, 47, 47, 0.3);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #404040, #606060);
        }

        /* Events Grid */
        .events-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 2rem;
        }

        .event-card {
            background: linear-gradient(145deg, #1a1f2e, #2d1b2e);
            border-radius: 15px;
            overflow: hidden;
            border: 1px solid #404040;
            transition: all 0.3s ease;
        }

        .event-card:hover {
            transform: translateY(-5px);
            border-color: #d32f2f;
            box-shadow: 0 15px 35px rgba(211, 47, 47, 0.2);
        }

        .event-header {
            background: linear-gradient(45deg, #d32f2f, #f57c00);
            padding: 1.5rem;
            text-align: center;
        }

        .event-header h3 {
            font-size: 1.3rem;
            margin-bottom: 0.5rem;
        }

        .event-date {
            opacity: 0.9;
            font-size: 0.9rem;
        }

        .event-body {
            padding: 1.5rem;
        }

        .event-location {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            color: #cccccc;
        }

        .fights-preview {
            margin-bottom: 1.5rem;
        }

        .fights-preview h4 {
            color: #d32f2f;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .fight-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.8rem;
            background: rgba(211, 47, 47, 0.1);
            border-radius: 8px;
            margin-bottom: 0.5rem;
            border-left: 3px solid #d32f2f;
        }

        .fighters {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .fighter {
            font-weight: 500;
        }

        .vs {
            color: #d32f2f;
            font-weight: bold;
        }

        .fight-status {
            padding: 0.3rem 0.8rem;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .status-live {
            background: #4caf50;
        }

        .status-upcoming {
            background: #ff9800;
        }

        .status-finished {
            background: #757575;
        }

        .event-actions {
            display: flex;
            gap: 1rem;
        }

        .event-actions .btn {
            flex: 1;
            justify-content: center;
        }

        /* Live Fight View */
        .live-fight {
            display: none;
            padding: 2rem;
        }

        .live-fight.active {
            display: block;
        }

        .fight-header {
            text-align: center;
            margin-bottom: 3rem;
            padding: 2rem;
            background: linear-gradient(145deg, #1a1f2e, #2d1b2e);
            border-radius: 15px;
            border: 2px solid #d32f2f;
        }

        .fight-title {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            background: linear-gradient(45deg, #d32f2f, #f57c00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .fighters-vs {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 3rem;
            margin: 2rem 0;
        }

        .fighter-card {
            text-align: center;
            flex: 1;
            max-width: 200px;
        }

        .fighter-avatar {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: linear-gradient(45deg, #d32f2f, #f57c00);
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 1rem;
            font-size: 2rem;
        }

        .fighter-name {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .fighter-record {
            color: #cccccc;
            font-size: 0.9rem;
        }

        .vs-separator {
            font-size: 3rem;
            color: #d32f2f;
            font-weight: bold;
        }

        /* Live Stats */
        .live-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin-bottom: 3rem;
        }

        .stats-panel {
            background: linear-gradient(145deg, #1a1f2e, #2d1b2e);
            padding: 2rem;
            border-radius: 15px;
            border: 1px solid #404040;
        }

        .stats-panel h3 {
            color: #d32f2f;
            margin-bottom: 1.5rem;
            font-size: 1.3rem;
            text-align: center;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.8rem 0;
            border-bottom: 1px solid #404040;
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            color: #cccccc;
        }

        .stat-values {
            display: flex;
            gap: 1rem;
            font-weight: bold;
        }

        .stat-blue {
            color: #2196f3;
        }

        .stat-red {
            color: #d32f2f;
        }

        /* Probability Panel */
        .probability-panel {
            background: linear-gradient(145deg, #1a1f2e, #2d1b2e);
            padding: 2rem;
            border-radius: 15px;
            border: 1px solid #404040;
            text-align: center;
        }

        .probability-chart {
            display: flex;
            height: 20px;
            border-radius: 10px;
            overflow: hidden;
            margin: 1rem 0;
            background: #404040;
        }

        .prob-blue {
            background: #2196f3;
            transition: width 0.5s ease;
        }

        .prob-red {
            background: #d32f2f;
            transition: width 0.5s ease;
        }

        .prob-values {
            display: flex;
            justify-content: space-between;
            margin-top: 1rem;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .main-content {
                padding: 1rem;
            }

            .nav-menu {
                display: none;
            }

            .dashboard-header h1 {
                font-size: 2rem;
            }

            .fighters-vs {
                flex-direction: column;
                gap: 1rem;
            }

            .vs-separator {
                transform: rotate(90deg);
            }

            .live-stats {
                grid-template-columns: 1fr;
            }
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #404040;
            border-radius: 50%;
            border-top-color: #d32f2f;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Toast Notifications */
        .toast {
            position: fixed;
            top: 100px;
            right: 20px;
            background: #d32f2f;
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            z-index: 3000;
            transform: translateX(400px);
            transition: transform 0.3s ease;
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast.success {
            background: #4caf50;
        }

        .toast.error {
            background: #f44336;
        }

        /* Hidden class */
        .hidden {
            display: none !important;
        }

        .event-modal {
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .event-modal .fight-detail-item {
            transition: all 0.3s ease;
        }

        .event-modal .fight-detail-item:hover {
            transform: translateX(5px);
            background: rgba(211, 47, 47, 0.2) !important;
        }

        /* Estado de peleas mejorado */
        .fight-status {
            padding: 0.3rem 0.8rem;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status-live {
            background: linear-gradient(45deg, #4caf50, #66bb6a);
            animation: pulse 2s infinite;
        }

        .status-upcoming {
            background: linear-gradient(45deg, #ff9800, #ffb74d);
        }

        .status-finished {
            background: linear-gradient(45deg, #757575, #9e9e9e);
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(76, 175, 80, 0); }
            100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0); }
        }

        /* Mensaje de no hay peleas en vivo */
        .no-live-fights {
            animation: slideInDown 0.5s ease;
        }

        @keyframes slideInDown {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* Mejoras para las tarjetas de eventos */
        .event-card .fights-preview {
            max-height: 300px;
            overflow-y: auto;
        }

        .event-card .fights-preview::-webkit-scrollbar {
            width: 4px;
        }

        .event-card .fights-preview::-webkit-scrollbar-track {
            background: #404040;
            border-radius: 2px;
        }

        .event-card .fights-preview::-webkit-scrollbar-thumb {
            background: #d32f2f;
            border-radius: 2px;
        }

        /* Loading state mejorado */
        .loading-events {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            padding: 3rem;
            color: #cccccc;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #404040;
            border-top: 4px solid #d32f2f;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* Responsivo para el modal de evento */
        @media (max-width: 768px) {
            .event-modal {
                padding: 1rem;
            }

            .event-modal > div {
                max-height: 90vh;
                border-radius: 15px;
            }

            .fight-detail-item .fighters {
                flex-direction: column;
                text-align: center;
                gap: 0.5rem;
            }

            .fight-detail-item .fighters > div:first-child,
            .fight-detail-item .fighters > div:last-child {
                text-align: center;
            }
        }

        /* Mejoras para el contador de peleas */
        .fights-preview h4 {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .fight-count-badge {
            background: rgba(211, 47, 47, 0.2);
            color: #d32f2f;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: normal;
        }

        /* Animaci√≥n para actualizar datos */
        .updating {
            animation: updating 0.5s ease;
        }

        @keyframes updating {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>
<!-- Header -->
<header class="header">
    <div class="nav-container">
        <div class="logo">
            <div class="ufc-logo">UFC</div>
            Live Tracker
        </div>
        <nav class="nav-menu" id="navMenu">
            <li><a href="#" onclick="showDashboardSimple()"><i class="fas fa-home"></i> Dashboard</a></li>
            <li><a href="#" onclick="showEvents()"><i class="fas fa-calendar"></i> Eventos</a></li>
            <li><a href="#" onclick="showFightsSimple()"><i class="fas fa-fire"></i> Peleas En Vivo</a></li>
        </nav>
        <div class="user-info" id="userInfo">
            <span id="userName"></span>
            <span class="user-badge" id="userRole"></span>
            <button onclick="logout()" class="btn btn-secondary">
                <i class="fas fa-sign-out-alt"></i> Salir
            </button>
            <button onclick="stopSimplePolling()" style="position: fixed; top: 100px; right: 10px; z-index: 9999; background: red; color: white; padding: 10px;">
                STOP POLLING
            </button>
            <button onclick="EMERGENCY_NUCLEAR_STOP()"
                    style="position: fixed; top: 10px; right: 10px; z-index: 99999;
               background: red; color: white; padding: 20px;
               font-size: 16px; font-weight: bold; border: none;
               border-radius: 10px; cursor: pointer;">
                üö® STOP NUCLEAR
            </button>
            <button onclick="console.log(getPollingStatus())" style="position: fixed; top: 140px; right: 10px; z-index: 9999; background: blue; color: white; padding: 10px;">
                CHECK STATUS
            </button>
        </div>
    </div>
</header>

<!-- Auth Modal -->
<div class="auth-modal" id="authModal">
    <div class="auth-container">
        <div class="auth-header">
            <h2><div class="ufc-logo">UFC</div> Live Tracker</h2>
            <p>Seguimiento en tiempo real de peleas UFC</p>
        </div>

        <!-- Login Form -->
        <form id="loginForm">
            <div class="form-group">
                <label for="loginEmail">Email</label>
                <input type="email" id="loginEmail" required>
            </div>
            <div class="form-group">
                <label for="loginPassword">Contrase√±a</label>
                <input type="password" id="loginPassword" required>
            </div>
            <button type="submit" class="auth-button">
                <span id="loginButtonText">Iniciar Sesi√≥n</span>
                <div class="loading hidden" id="loginLoading"></div>
            </button>
        </form>

        <!-- Register Form -->
        <form id="registerForm" class="hidden">
            <div class="form-group">
                <label for="registerName">Nombre</label>
                <input type="text" id="registerName" required>
            </div>
            <div class="form-group">
                <label for="registerEmail">Email</label>
                <input type="email" id="registerEmail" required>
            </div>
            <div class="form-group">
                <label for="registerPassword">Contrase√±a</label>
                <input type="password" id="registerPassword" required>
            </div>
            <button type="submit" class="auth-button">
                <span id="registerButtonText">Registrarse</span>
                <div class="loading hidden" id="registerLoading"></div>
            </button>
        </form>

        <div class="auth-switch">
            <span id="authSwitchText">¬øNo tienes cuenta?</span>
            <a href="#" id="authSwitchLink" onclick="toggleAuthMode()">Reg√≠strate aqu√≠</a>
        </div>
    </div>
</div>

<!-- Main Content -->
<main class="main-content">
    <!-- Dashboard -->
    <div class="dashboard active" id="dashboard">
        <div class="dashboard-header">
            <h1>ü•ä UFC Live Tracker</h1>
            <p>Tu plataforma definitiva para seguimiento en tiempo real de peleas y eventos UFC</p>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="icon"><i class="fas fa-calendar-alt"></i></div>
                <h3 id="totalEvents">-</h3>
                <p>Eventos Totales</p>
            </div>
            <div class="stat-card">
                <div class="icon"><i class="fas fa-fire"></i></div>
                <h3 id="liveFights">-</h3>
                <p>Peleas En Vivo</p>
            </div>
            <div class="stat-card">
                <div class="icon"><i class="fas fa-users"></i></div>
                <h3 id="totalFighters">-</h3>
                <p>Luchadores</p>
            </div>
            <div class="stat-card">
                <div class="icon"><i class="fas fa-trophy"></i></div>
                <h3 id="completedFights">-</h3>
                <p>Peleas Finalizadas</p>
            </div>
        </div>

        <div class="events-section">
            <div class="section-header">
                <h2><i class="fas fa-calendar"></i> Pr√≥ximos Eventos</h2>
                <div>
                    <button class="btn" onclick="refreshData()">
                        <i class="fas fa-sync-alt"></i> Actualizar
                    </button>
                    <button class="btn" onclick="createEvent()">
                        <i class="fas fa-plus"></i> Crear Evento
                    </button>
                </div>
            </div>
            <div class="events-grid" id="eventsGrid">
                <!-- Events will be loaded here -->
            </div>
        </div>
    </div>

    <!-- Live Fight View -->
    <div class="live-fight" id="liveFight">
        <div class="fight-header">
            <button class="btn btn-secondary" onclick="showDashboardSimple()" style="float: left;">
                <i class="fas fa-arrow-left"></i> Volver
            </button>

            <button onclick="window.emergencyStop()"
                    style="position: fixed; top: 50px; right: 10px; z-index: 9999;
               background: red; color: white; padding: 10px; border: none;
               border-radius: 5px; cursor: pointer;">
                üö® EMERGENCY STOP
            </button>
            <div class="fight-title">UFC 300 - Pelea Principal</div>
            <div class="fighters-vs">
                <div class="fighter-card">
                    <div class="fighter-avatar"> <img src="https://ssl.gstatic.com/onebox/media/sports/photos/ufc/3605_H-bQHA_96x96.png" alt="Avatar" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;">
                    </div>
                    <div class="fighter-name">Luchador Azul</div>
                    <div class="fighter-record" id="fighterRecord1">Cargando...</div>
                </div>
                <div class="vs-separator">VS</div>
                <div class="fighter-card">
                    <div class="fighter-avatar"> <img src="https://ssl.gstatic.com/onebox/media/sports/photos/ufc/1531_bqT22g_96x96.png" alt="Avatar" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;">
                    </div>
                    <div class="fighter-name">Luchador Rojo</div>
                    <div class="fighter-record" id="fighterRecord2">Cargando...</div>
                </div>
            </div>
            <div style="text-align: center; margin-top: 1rem;">
                <span class="fight-status status-live">üî¥ EN VIVO - Round 2</span>
            </div>
        </div>

        <div class="live-stats">
            <div class="stats-panel">
                <h3>üìä Estad√≠sticas del Round</h3>
                <div class="stat-row">
                    <span class="stat-label">Golpes Conectados</span>
                    <div class="stat-values">
                        <span class="stat-blue">20</span>
                        <span class="stat-red">7</span>
                    </div>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Derribos</span>
                    <div class="stat-values">
                        <span class="stat-blue">7</span>
                        <span class="stat-red">3</span>
                    </div>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Control de Jaula</span>
                    <div class="stat-values">
                        <span class="stat-blue">3:45</span>
                        <span class="stat-red">1:15</span>
                    </div>
                </div>
            </div>

            <div class="probability-panel">
                <h3>üéØ Probabilidades de Victoria</h3>
                <div class="probability-chart">
                    <div class="prob-blue" style="width: 75%;"></div>
                    <div class="prob-red" style="width: 25%;"></div>
                </div>
                <div class="prob-values">
                    <span class="stat-blue">75%</span>
                    <span class="stat-red">25%</span>
                </div>
                <p style="color: #cccccc; margin-top: 1rem; font-size: 0.9rem;">
                    Actualizado hace 5 segundos
                </p>
            </div>
        </div>
    </div>
</main>

<script>
    // Global state
    let currentUser = null;
    let isLoginMode = true;
    let liveWebSocket = null;
    const API_BASE = 'http://localhost:8080/api';
    let liveDataInterval = null; // ‚úÖ AGREGAR ESTA L√çNEA
    let currentFightData = null;  // ‚úÖ TAMBI√âN AGREGAR ESTA SI NO EXISTE

    // Initialize app
    document.addEventListener('DOMContentLoaded', function() {
        checkAuthStatus();
        setupEventListeners();
    });

    async function loadFightersForEvent(eventoId) {
        try {
            const response = await fetch(`${API_BASE}/luchadores`, {
                headers: {
                    'Authorization': `Basic ${currentUser.credentials}`,
                    'Content-Type': 'application/json'
                }
            });

            if (response.ok) {
                const luchadores = await response.json();

                // Buscar luchadores espec√≠ficos para mostrar en la vista en vivo
                const topuria = luchadores.find(l => l.nombre === 'Ilia Topuria');
                const oliveira = luchadores.find(l => l.nombre === 'Charles Oliveira');

                if (topuria && oliveira) {
                    updateFighterDisplay('blue', topuria);
                    updateFighterDisplay('red', oliveira);
                }
            }
        } catch (error) {
            console.error('Error cargando luchadores:', error);
        }
    }

    // FUNCI√ìN PARA ACTUALIZAR LA INFORMACI√ìN DE UN LUCHADOR EN LA UI
    function updateFighterDisplay(corner, fighter) {
        const fighterCard = document.querySelector(`.fighter-card.${corner}`);
        if (fighterCard) {
            // Actualizar nombre
            const nameElement = fighterCard.querySelector('.fighter-name');
            if (nameElement) {
                nameElement.textContent = fighter.nombre;
            }

            // Actualizar historial
            const recordElement = fighterCard.querySelector('.fighter-record');
            if (recordElement) {
                recordElement.textContent = fighter.historial || 'N/A';
            }

            // Actualizar nacionalidad si existe
            const nationalityElement = fighterCard.querySelector('.fighter-nationality');
            if (nationalityElement) {
                nationalityElement.textContent = fighter.nacionalidad || '';
            }

            // Actualizar categor√≠a de peso si existe
            const weightClassElement = fighterCard.querySelector('.fighter-weight-class');
            if (weightClassElement) {
                weightClassElement.textContent = fighter.categoriaPeso || '';
            }
        }
    }

    async function crearEstadisticasPrueba(peleaId, luchadorAzulId, luchadorRojoId) {
        if (!currentUser || currentUser.rol !== 'admin') {
            showToast('Solo los administradores pueden crear estad√≠sticas de prueba', 'error');
            return;
        }

        try {
            console.log(`üß™ Creando estad√≠sticas de prueba para pelea ${peleaId}...`);

            // Crear estad√≠sticas para el luchador azul
            const statsAzul = {
                peleaId: peleaId,
                luchadorId: luchadorAzulId,
                round: 2,
                golpesConectados: Math.floor(Math.random() * 20) + 15,
                derribos: Math.floor(Math.random() * 3) + 1,
                controlJaulaSegundos: Math.floor(Math.random() * 180) + 120,
                timestamp: new Date().toISOString()
            };

            // Crear estad√≠sticas para el luchador rojo
            const statsRojo = {
                peleaId: peleaId,
                luchadorId: luchadorRojoId,
                round: 2,
                golpesConectados: Math.floor(Math.random() * 15) + 8,
                derribos: Math.floor(Math.random() * 2),
                controlJaulaSegundos: Math.floor(Math.random() * 120) + 60,
                timestamp: new Date().toISOString()
            };

            console.log('üìä Estad√≠sticas a crear:', { statsAzul, statsRojo });

            // Enviar estad√≠sticas a la API
            const responses = await Promise.all([
                authenticatedFetch(`${API_BASE}/estadisticas`, {
                    method: 'POST',
                    body: JSON.stringify(statsAzul)
                }),
                authenticatedFetch(`${API_BASE}/estadisticas`, {
                    method: 'POST',
                    body: JSON.stringify(statsRojo)
                })
            ]);

            if (responses[0].ok && responses[1].ok) {
                console.log('‚úÖ Estad√≠sticas de prueba creadas exitosamente');
                showToast('Estad√≠sticas de prueba creadas', 'success');

                // Recargar estad√≠sticas en la vista
                setTimeout(() => {
                    loadRealFightStatistics(peleaId, luchadorAzulId, luchadorRojoId);
                }, 1000);
            } else {
                throw new Error('Error creando estad√≠sticas en la API');
            }

        } catch (error) {
            console.error('‚ùå Error creando estad√≠sticas de prueba:', error);
            showToast('Error creando estad√≠sticas de prueba: ' + error.message, 'error');
        }
    }

    async function crearProbabilidadesPrueba(peleaId, luchadorAzulId, luchadorRojoId) {
        if (!currentUser || currentUser.rol !== 'admin') {
            showToast('Solo los administradores pueden crear probabilidades de prueba', 'error');
            return;
        }

        try {
            console.log(`üéØ Creando probabilidades de prueba para pelea ${peleaId}...`);

            // Generar probabilidades aleatorias que sumen 100%
            const probAzul = Math.floor(Math.random() * 60) + 20; // Entre 20-80%
            const probRojo = 100 - probAzul;

            const probAzulData = {
                peleaId: peleaId,
                luchadorId: luchadorAzulId,
                probabilidad: probAzul,
                timestamp: new Date().toISOString()
            };

            const probRojoData = {
                peleaId: peleaId,
                luchadorId: luchadorRojoId,
                probabilidad: probRojo,
                timestamp: new Date().toISOString()
            };

            console.log('üéØ Probabilidades a crear:', { probAzulData, probRojoData });

            // Enviar probabilidades a la API
            const responses = await Promise.all([
                authenticatedFetch(`${API_BASE}/probabilidades`, {
                    method: 'POST',
                    body: JSON.stringify(probAzulData)
                }),
                authenticatedFetch(`${API_BASE}/probabilidades`, {
                    method: 'POST',
                    body: JSON.stringify(probRojoData)
                })
            ]);

            if (responses[0].ok && responses[1].ok) {
                console.log('‚úÖ Probabilidades de prueba creadas exitosamente');
                showToast('Probabilidades de prueba creadas', 'success');

                // Recargar probabilidades en la vista
                setTimeout(() => {
                    loadRealFightStatistics(peleaId, luchadorAzulId, luchadorRojoId);
                }, 1000);
            } else {
                throw new Error('Error creando probabilidades en la API');
            }

        } catch (error) {
            console.error('‚ùå Error creando probabilidades de prueba:', error);
            showToast('Error creando probabilidades de prueba: ' + error.message, 'error');
        }
    }
    async function completarSetupPeleaEnVivo(peleaId, luchadorAzulId, luchadorRojoId) {
        if (!currentUser || currentUser.rol !== 'admin') {
            showToast('Solo los administradores pueden completar el setup', 'error');
            return;
        }

        try {
            console.log(`üõ†Ô∏è Completando setup para pelea ${peleaId}...`);
            showToast('Creando estad√≠sticas y probabilidades de prueba...', 'success');

            // Crear estad√≠sticas y probabilidades en paralelo
            await Promise.all([
                crearEstadisticasPrueba(peleaId, luchadorAzulId, luchadorRojoId),
                crearProbabilidadesPrueba(peleaId, luchadorAzulId, luchadorRojoId)
            ]);

            console.log('‚úÖ Setup completado para la pelea');
            showToast('Setup de pelea completado exitosamente', 'success');

        } catch (error) {
            console.error('‚ùå Error completando setup:', error);
            showToast('Error completando setup de la pelea', 'error');
        }
    }

    function showFightsSinWebSocket() {
        console.log('üî¥ Mostrando secci√≥n de peleas en vivo (SIN WebSocket)...');
        hideAllViews();
        document.getElementById('liveFight').classList.add('active');

        loadLiveFightsTemp().then(peleasEnVivo => {
            if (peleasEnVivo.length === 0) {
                console.log('‚ùå No hay peleas EN VIVO ahora mismo - mostrando mensaje');
                showNoLiveFightsMessage();
                return;
            }

            console.log(`‚úÖ Encontradas ${peleasEnVivo.length} peleas EN VIVO - mostrando la primera`);
            const pelea = peleasEnVivo[0];
            displayFightInfo(pelea);

            // NO CONECTAR WEBSOCKET por ahora
            console.log('‚ÑπÔ∏è WebSocket deshabilitado temporalmente');
        }).catch(error => {
            console.error('‚ùå Error cargando peleas en vivo:', error);
            showNoLiveFightsMessage();
        });
    }

    function emergencyStop() {
        console.log('üö® PARADA DE EMERGENCIA');
        stopSimplePolling();
        cleanupSimple();
    }

    window.stopSimplePolling = stopSimplePolling;
    window.getPollingStatus = getPollingStatus;
    window.emergencyStop = emergencyStop;
    window.cleanupSimple = cleanupSimple;

    function EMERGENCY_NUCLEAR_STOP() {
        // Parar TODOS los timers brutalmente
        for (let i = 1; i < 50000; i++) {
            clearInterval(i);
            clearTimeout(i);
        }

        // Reset variables
        if (typeof pollingTimer !== 'undefined') pollingTimer = null;
        if (typeof isPollingActive !== 'undefined') isPollingActive = false;
        if (typeof requestInProgress !== 'undefined') requestInProgress = false;
        if (typeof liveDataInterval !== 'undefined') liveDataInterval = null;

        // Parar WebSocket
        if (typeof liveWebSocket !== 'undefined' && liveWebSocket) {
            try { liveWebSocket.disconnect(); } catch(e) {}
            liveWebSocket = null;
        }

        alert('üö® TODO PARADO - RECARGA LA P√ÅGINA');
        location.reload(); // Forzar recarga
    }

    // ACTUALIZAR LA FUNCI√ìN showFights PARA CARGAR DATOS REALES
    async function showFights() {
        console.log('üî¥ Mostrando secci√≥n de peleas en vivo...');
        hideAllViews();
        document.getElementById('liveFight').classList.add('active');

        try {
            // CORREGIDO: Usar la funci√≥n que ya filtra correctamente
            const peleasEnVivo = await loadLiveFightsTemp();

            console.log(`üîç Resultado de loadLiveFightsTemp: ${peleasEnVivo.length} peleas`);

            if (peleasEnVivo.length === 0) {
                console.log('‚ùå No hay peleas EN VIVO ahora mismo - mostrando mensaje');
                showNoLiveFightsMessage();
                return;
            }

            console.log(`‚úÖ Encontradas ${peleasEnVivo.length} peleas EN VIVO - mostrando la primera`);
            console.log('üî¥ Peleas en vivo disponibles:', peleasEnVivo.map(p => ({
                id: p.id,
                fecha: p.fecha,
                finalizada: p.finalizada
            })));

            // CORREGIDO: Usar la primera pelea de las que est√°n realmente en vivo
            const pelea = peleasEnVivo[0];
            console.log('ü•ä Pelea seleccionada para mostrar:', pelea);

            await displayFightInfo(pelea);

            // Conectar WebSocket solo si hay peleas en vivo
            if (!liveWebSocket) {
                liveWebSocket = new LiveFightWebSocket();
            }
            liveWebSocket.enable(); // Habilitar reconexiones
            liveWebSocket.connect();

        } catch (error) {
            console.error('‚ùå Error cargando peleas en vivo:', error);
            showNoLiveFightsMessage();
        }
    }


    async function renderEventsWithFighters(eventos) {
        const eventsGrid = document.getElementById('eventsGrid');

        if (eventos.length === 0) {
            eventsGrid.innerHTML = `
            <div style="grid-column: 1/-1; text-align: center; padding: 3rem; color: #cccccc;">
                <i class="fas fa-calendar-times" style="font-size: 3rem; margin-bottom: 1rem; color: #666;"></i>
                <h3>No hay eventos disponibles</h3>
                <p>Crea tu primer evento para comenzar</p>
                ${currentUser.rol === 'admin' ? `
                    <button class="btn" onclick="createEvent()" style="margin-top: 1rem;">
                        <i class="fas fa-plus"></i> Crear Evento
                    </button>
                ` : ''}
            </div>
        `;
            return;
        }

        console.log('üìÖ Renderizando eventos con detecci√≥n corregida de peleas en vivo:', eventos.length);

        // Mostrar mensaje de carga
        eventsGrid.innerHTML = `
        <div style="grid-column: 1/-1; text-align: center; padding: 2rem; color: #cccccc;">
            <div class="loading-spinner"></div>
            <p>Cargando peleas de los eventos...</p>
        </div>
    `;

        // Cargar luchadores para mostrar nombres
        let luchadores = [];
        try {
            const response = await authenticatedFetch(`${API_BASE}/luchadores`);
            if (response.ok) {
                luchadores = await response.json();
                console.log('üë• Luchadores cargados:', luchadores.length);
            }
        } catch (error) {
            console.error('‚ùå Error cargando luchadores:', error);
        }

        // Cargar peleas para cada evento
        const eventosConPeleas = [];
        for (const evento of eventos) {
            console.log(`üìã Procesando evento: ${evento.nombre} (ID: ${evento.id})`);
            try {
                const peleasDelEvento = await loadFightsForEventTemp(evento.id);

                // CORREGIDO: Clasificar peleas correctamente
                const peleasClasificadas = clasificarPeleas(peleasDelEvento);

                eventosConPeleas.push({
                    ...evento,
                    peleas: peleasDelEvento,
                    peleasEnVivo: peleasClasificadas.enVivo,
                    peleasFuturas: peleasClasificadas.futuras,
                    peleasFinalizadas: peleasClasificadas.finalizadas
                });

                console.log(`‚úÖ Evento ${evento.nombre}: ${peleasDelEvento.length} peleas (${peleasClasificadas.enVivo.length} en vivo, ${peleasClasificadas.futuras.length} futuras, ${peleasClasificadas.finalizadas.length} finalizadas)`);
            } catch (error) {
                console.error(`‚ùå Error cargando peleas para evento ${evento.id}:`, error);
                eventosConPeleas.push({ ...evento, peleas: [], peleasEnVivo: [], peleasFuturas: [], peleasFinalizadas: [] });
            }
        }

        console.log('üéØ Todos los eventos procesados, renderizando HTML...');

        eventsGrid.innerHTML = eventosConPeleas.map(evento => {
            const totalPeleas = evento.peleas.length;
            const enVivo = evento.peleasEnVivo.length;
            const futuras = evento.peleasFuturas.length;
            const finalizadas = evento.peleasFinalizadas.length;

            // Crear resumen de estado
            let estadoInfo = '';
            if (totalPeleas > 0) {
                const estados = [];
                if (enVivo > 0) estados.push(`${enVivo} en vivo`);
                if (futuras > 0) estados.push(`${futuras} futuras`);
                if (finalizadas > 0) estados.push(`${finalizadas} finalizadas`);
                estadoInfo = estados.length > 0 ? ` (${estados.join(', ')})` : '';
            }

            // Mostrar hasta 3 peleas m√°s relevantes (en vivo primero, luego futuras)
            const peleasParaMostrar = [
                ...evento.peleasEnVivo.slice(0, 2),
                ...evento.peleasFuturas.slice(0, 3 - evento.peleasEnVivo.slice(0, 2).length)
            ];

            const peleasHTML = peleasParaMostrar.length > 0
                ? peleasParaMostrar.map(pelea => {
                    const luchadorAzul = luchadores.find(l => l.id === pelea.luchadorAzulId);
                    const luchadorRojo = luchadores.find(l => l.id === pelea.luchadorRojoId);
                    const estadoReal = determinarEstadoPeleaReal(pelea);

                    return `
                    <div class="fight-item">
                        <div class="fighters">
                            <span class="fighter">${luchadorAzul ? luchadorAzul.nombre : 'Luchador TBD'}</span>
                            ${luchadorAzul && luchadorAzul.historial ?
                        `<span class="fighter-record">(${luchadorAzul.historial})</span>` : ''}
                            <span class="vs">VS</span>
                            <span class="fighter">${luchadorRojo ? luchadorRojo.nombre : 'Luchador TBD'}</span>
                            ${luchadorRojo && luchadorRojo.historial ?
                        `<span class="fighter-record">(${luchadorRojo.historial})</span>` : ''}
                        </div>
                        <span class="fight-status ${getFightStatusClass(pelea)}">
                            ${getFightStatusText(pelea)}
                        </span>
                    </div>
                `;
                }).join('')
                : `
                <div class="fight-item">
                    <div class="fighters">
                        <span class="fighter">No hay peleas programadas</span>
                    </div>
                    <span class="fight-status status-upcoming">Por definir</span>
                </div>
            `;

            const peleasInfo = totalPeleas > 0
                ? `${totalPeleas} pelea${totalPeleas !== 1 ? 's' : ''}`
                : 'Sin peleas';

            // Determinar si hay alguna pelea en vivo para destacar el evento
            const tieneEnVivo = enVivo > 0;

            return `
            <div class="event-card ${tieneEnVivo ? 'live-event' : ''}">
                <div class="event-header">
                    <h3>${evento.nombre} ${tieneEnVivo ? 'üî¥' : ''}</h3>
                    <div class="event-date">
                        <i class="fas fa-calendar"></i>
                        ${formatDate(evento.fecha)}
                    </div>
                </div>
                <div class="event-body">
                    <div class="event-location">
                        <i class="fas fa-map-marker-alt"></i>
                        ${evento.ubicacion || 'Ubicaci√≥n por definir'}
                    </div>
                    <div class="fights-preview">
                        <h4>
                            <span><i class="fas fa-fist-raised"></i> Peleas (${peleasInfo}${estadoInfo})</span>
                            ${tieneEnVivo ? '<span class="fight-count-badge live-badge">EN VIVO</span>' : ''}
                        </h4>
                        ${peleasHTML}
                        ${totalPeleas > peleasParaMostrar.length ?
                `<div style="text-align: center; margin-top: 1rem; color: #d32f2f; font-size: 0.9rem;">
                                <i class="fas fa-plus-circle"></i> ${totalPeleas - peleasParaMostrar.length} peleas m√°s
                            </div>` : ''}
                    </div>
                    <div class="event-actions">
                        <button class="btn" onclick="viewEvent(${evento.id})">
                            <i class="fas fa-eye"></i> Ver Evento
                        </button>
                        ${tieneEnVivo ? `
                            <button class="btn" onclick="verPeleasEnVivo(${evento.id})" style="background: linear-gradient(45deg, #4caf50, #66bb6a);">
                                <i class="fas fa-play"></i> Ver En Vivo
                            </button>
                        ` : ''}
                        ${currentUser.rol === 'admin' ?
                `<button class="btn btn-secondary" onclick="editEvent(${evento.id})">
                                <i class="fas fa-edit"></i> Editar
                            </button>` : ''}
                    </div>
                </div>
            </div>
        `;
        }).join('');

        console.log('‚úÖ Eventos renderizados con detecci√≥n corregida de estado');
    }

    function clasificarPeleas(peleas) {
        const ahora = new Date();
        const clasificacion = {
            enVivo: [],
            futuras: [],
            finalizadas: []
        };

        peleas.forEach(pelea => {
            if (pelea.finalizada) {
                clasificacion.finalizadas.push(pelea);
            } else {
                const fechaPelea = parseFechaSafe(pelea.fecha);
                if (fechaPelea && fechaPelea <= ahora) {
                    clasificacion.enVivo.push(pelea);
                } else {
                    clasificacion.futuras.push(pelea);
                }
            }
        });

        return clasificacion;
    }

    async function verPeleasEnVivo(eventoId) {
        try {
            const peleasDelEvento = await loadFightsForEventTemp(eventoId);
            const clasificadas = clasificarPeleas(peleasDelEvento);

            if (clasificadas.enVivo.length > 0) {
                console.log(`üî¥ Yendo a pelea en vivo del evento ${eventoId}`);
                hideAllViews();
                document.getElementById('liveFight').classList.add('active');

                // Mostrar la primera pelea en vivo del evento
                await displayFightInfo(clasificadas.enVivo[0]);

                // Conectar WebSocket
                if (!liveWebSocket) {
                    liveWebSocket = new LiveFightWebSocket();
                }
                liveWebSocket.enable();
                liveWebSocket.connect();

                showToast(`Viendo pelea en vivo: ${clasificadas.enVivo[0].id}`, 'success');
            } else {
                showToast('No hay peleas en vivo en este evento ahora mismo', 'error');
            }
        } catch (error) {
            console.error('Error yendo a peleas en vivo:', error);
            showToast('Error accediendo a peleas en vivo', 'error');
        }
    }

    async function testEndpointsWithTime() {
        console.log('üß™ INICIANDO TESTS DE ENDPOINTS CON L√ìGICA DE TIEMPO...');

        const endpoints = [
            { name: 'Todas las peleas', url: '/api/peleas' },
            { name: 'Peleas EN VIVO (que ya empezaron)', url: '/api/peleas/live' },
            { name: 'Peleas FUTURAS (que no han empezado)', url: '/api/peleas/upcoming' },
            { name: 'Peleas ACTIVAS (futuras + en vivo)', url: '/api/peleas/active' },
            { name: 'Peleas FINALIZADAS', url: '/api/peleas/finished' }
        ];

        const ahora = new Date();
        console.log('üïê Hora actual del navegador:', ahora.toISOString());

        for (const endpoint of endpoints) {
            try {
                console.log(`\nüîç Probando: ${endpoint.name}`);
                const response = await fetch(`${API_BASE}${endpoint.url}`, {
                    headers: {
                        'Authorization': `Basic ${currentUser.credentials}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    console.log(`‚úÖ ${endpoint.name} (${data.length} peleas):`, data);

                    // An√°lisis adicional para endpoints de peleas
                    if (endpoint.url.includes('/peleas')) {
                        data.forEach(pelea => {
                            const fechaPelea = new Date(pelea.fecha);
                            const estado = determinarEstadoPeleaReal(pelea);
                            console.log(`  - ID: ${pelea.id}, Fecha: ${fechaPelea.toISOString()}, Estado: ${estado}, Finalizada: ${pelea.finalizada}`);
                        });
                    }
                } else {
                    console.error(`‚ùå ${endpoint.name} - Error ${response.status}:`, response.statusText);
                }
            } catch (error) {
                console.error(`‚ùå ${endpoint.name} - Error:`, error);
            }
        }

        console.log('\nüìä RESUMEN DE PRUEBAS COMPLETADO');
    }

    function parseFechaSafe(fechaString) {
        if (!fechaString) {
            console.warn('‚ö†Ô∏è Fecha vac√≠a o null:', fechaString);
            return null;
        }

        try {
            // Si es un array (problema detectado en los logs), convertir a string
            if (Array.isArray(fechaString)) {
                console.warn('‚ö†Ô∏è Fecha es un array:', fechaString);
                if (fechaString.length >= 6) {
                    const [year, month, day, hour, minute, second, nanosecond] = fechaString;
                    const millisecond = nanosecond ? Math.floor(nanosecond / 1000000) : 0;
                    const fecha = new Date(year, month - 1, day, hour || 0, minute || 0, second || 0, millisecond);
                    console.log('‚úÖ Fecha convertida desde array:', fecha.toISOString());
                    return fecha;
                }
                return null;
            }

            // CORREGIDO: Manejar diferentes formatos de fecha
            let fecha;

            // Si la fecha no tiene 'Z' o zona horaria, agregarla
            if (typeof fechaString === 'string' && !fechaString.includes('Z') && !fechaString.includes('+') && !fechaString.includes('-', 10)) {
                // Es una fecha sin zona horaria, asumirla como UTC
                fecha = new Date(fechaString + 'Z');
                console.log(`üîß Fecha sin zona horaria, agregando Z: ${fechaString} -> ${fecha.toISOString()}`);
            } else {
                fecha = new Date(fechaString);
            }

            if (isNaN(fecha.getTime())) {
                console.error('‚ùå Fecha inv√°lida despu√©s del parsing:', fechaString);
                return null;
            }

            return fecha;
        } catch (error) {
            console.error('‚ùå Error parseando fecha:', fechaString, error);
            return null;
        }
    }

    async function crearPeleaAhoraMismoCorregida() {
        console.log('üïê CREANDO PELEA QUE EMPEZ√ì AHORA MISMO (versi√≥n corregida)...');

        if (!currentUser || currentUser.rol !== 'admin') {
            showToast('Necesitas ser admin para crear peleas de prueba', 'error');
            return;
        }

        try {
            // Obtener eventos y luchadores
            const [eventosRes, luchadoresRes] = await Promise.all([
                authenticatedFetch(`${API_BASE}/eventos`),
                authenticatedFetch(`${API_BASE}/luchadores`)
            ]);

            const eventos = await eventosRes.json();
            const luchadores = await luchadoresRes.json();

            if (eventos.length === 0 || luchadores.length < 2) {
                showToast('Necesitas al menos 1 evento y 2 luchadores', 'error');
                return;
            }

            // Crear fecha que empez√≥ hace 5 minutos
            const ahora = new Date();
            const fechaPelea = new Date(ahora.getTime() - 5 * 60 * 1000); // Hace 5 minutos

            console.log('üïê Fechas:');
            console.log(`  Ahora: ${ahora.toISOString()}`);
            console.log(`  Pelea (hace 5 min): ${fechaPelea.toISOString()}`);

            const nuevaPelea = {
                eventoId: eventos[0].id,
                luchadorAzulId: luchadores[0].id,
                luchadorRojoId: luchadores[1].id,
                fecha: fechaPelea.toISOString(),
                finalizada: false
            };

            console.log('üìù Creando pelea:', nuevaPelea);

            const response = await authenticatedFetch(`${API_BASE}/peleas`, {
                method: 'POST',
                body: JSON.stringify(nuevaPelea)
            });

            if (response.ok) {
                const created = await response.json();
                console.log('‚úÖ Pelea creada:', created);

                // Verificar inmediatamente que se detecte como en vivo
                setTimeout(async () => {
                    const peleasEnVivo = await loadLiveFightsTemp();
                    const nuevaPeleaEncontrada = peleasEnVivo.find(p => p.id === created.id);

                    if (nuevaPeleaEncontrada) {
                        console.log('üéâ ¬°√âXITO! Nueva pelea detectada como en vivo');
                        showToast('¬°Pelea en vivo creada y detectada correctamente!', 'success');

                        // Actualizar estad√≠sticas
                        await loadStats();
                        await loadDashboardData();
                    } else {
                        console.log('‚ùå Pelea no detectada como en vivo');
                        showToast('Pelea creada pero no detectada como en vivo', 'error');
                    }
                }, 1000);

            } else {
                const error = await response.text();
                console.error('‚ùå Error creando pelea:', error);
                showToast('Error creando pelea: ' + error, 'error');
            }

        } catch (error) {
            console.error('‚ùå Error:', error);
            showToast('Error: ' + error.message, 'error');
        }
    }

    async function testDeteccionPeleasEnVivo() {
        console.log('üß™ TEST COMPLETO DE DETECCI√ìN DE PELEAS EN VIVO');
        console.log('='.repeat(50));

        try {
            // Test 1: Cargar todas las peleas
            console.log('\n1Ô∏è‚É£ Obteniendo todas las peleas...');
            const response = await authenticatedFetch(`${API_BASE}/peleas`);
            if (!response.ok) throw new Error('Error obteniendo peleas');

            const todasLasPeleas = await response.json();
            console.log(`‚úÖ Total peleas: ${todasLasPeleas.length}`);

            // Test 2: Analizar cada pelea individualmente
            console.log('\n2Ô∏è‚É£ Analizando cada pelea individualmente...');
            const ahora = new Date();
            console.log(`üïê Hora actual: ${ahora.toISOString()}`);

            let contadorEnVivo = 0;
            let contadorFuturas = 0;
            let contadorFinalizadas = 0;

            todasLasPeleas.forEach((pelea, index) => {
                console.log(`\nüìä Pelea ${index + 1} (ID: ${pelea.id}):`);
                console.log(`  - Finalizada: ${pelea.finalizada}`);
                console.log(`  - Fecha raw: ${JSON.stringify(pelea.fecha)}`);

                if (pelea.finalizada) {
                    console.log(`  - Estado: FINALIZADA ‚úÖ`);
                    contadorFinalizadas++;
                    return;
                }

                const fechaPelea = parseFechaSafe(pelea.fecha);
                if (!fechaPelea) {
                    console.log(`  - Estado: ERROR (fecha inv√°lida) ‚ùå`);
                    return;
                }

                console.log(`  - Fecha parseada: ${fechaPelea.toISOString()}`);

                const diferenciaMs = ahora.getTime() - fechaPelea.getTime();
                const diferenciaMinutos = diferenciaMs / (1000 * 60);
                const estaEnVivo = diferenciaMs >= 0;

                console.log(`  - Diferencia: ${diferenciaMinutos.toFixed(1)} minutos`);
                console.log(`  - ¬øYa empez√≥?: ${estaEnVivo ? 'S√ç' : 'NO'}`);

                if (estaEnVivo) {
                    console.log(`  - Estado: EN VIVO üî¥`);
                    contadorEnVivo++;
                } else {
                    console.log(`  - Estado: FUTURA ‚è∞`);
                    contadorFuturas++;
                }
            });

            // Test 3: Usar funci√≥n de filtrado
            console.log('\n3Ô∏è‚É£ Probando funci√≥n loadLiveFightsTemp()...');
            const peleasEnVivoDetectadas = await loadLiveFightsTemp();

            // Test 4: Comparar resultados
            console.log('\n4Ô∏è‚É£ COMPARACI√ìN DE RESULTADOS:');
            console.log(`üìä An√°lisis manual:`);
            console.log(`  - En vivo: ${contadorEnVivo}`);
            console.log(`  - Futuras: ${contadorFuturas}`);
            console.log(`  - Finalizadas: ${contadorFinalizadas}`);

            console.log(`üìä Funci√≥n loadLiveFightsTemp():`);
            console.log(`  - En vivo detectadas: ${peleasEnVivoDetectadas.length}`);

            const coinciden = contadorEnVivo === peleasEnVivoDetectadas.length;
            console.log(`\n‚úÖ ¬øCoinciden los resultados?: ${coinciden ? 'S√ç ‚úÖ' : 'NO ‚ùå'}`);

            if (!coinciden) {
                console.log('üîç DISCREPANCIA DETECTADA - Investigando...');
                console.log('IDs detectadas manualmente:',
                    todasLasPeleas
                        .filter(p => !p.finalizada && parseFechaSafe(p.fecha) && parseFechaSafe(p.fecha) <= ahora)
                        .map(p => p.id)
                );
                console.log('IDs detectadas por funci√≥n:', peleasEnVivoDetectadas.map(p => p.id));
            }

            // Test 5: Probar la vista
            console.log('\n5Ô∏è‚É£ RECOMENDACIONES:');
            if (peleasEnVivoDetectadas.length > 0) {
                console.log('‚úÖ HAY PELEAS EN VIVO - Ejecuta showFights() para verlas');
                console.log('üéØ Peleas disponibles:');
                peleasEnVivoDetectadas.forEach((pelea, index) => {
                    console.log(`  ${index + 1}. ID ${pelea.id} - ${parseFechaSafe(pelea.fecha)?.toLocaleString('es-ES')}`);
                });
            } else {
                console.log('‚ùå NO HAY PELEAS EN VIVO');
                console.log('üí° Para crear peleas de prueba, ejecuta: crearPeleaAhoraMismoCorregida()');
            }

            return {
                total: todasLasPeleas.length,
                enVivo: peleasEnVivoDetectadas.length,
                futuras: contadorFuturas,
                finalizadas: contadorFinalizadas,
                funcionandoCorrectamente: coinciden
            };

        } catch (error) {
            console.error('‚ùå Error en test:', error);
            return null;
        }
    }

    function showFightsCorregido() {
        console.log('üî¥ FUNCI√ìN CORREGIDA: Mostrando peleas en vivo...');

        // Primero, hacer el test completo
        testDeteccionPeleasEnVivo().then(resultado => {
            if (resultado && resultado.enVivo > 0) {
                console.log(`‚úÖ ${resultado.enVivo} peleas en vivo detectadas - Procediendo a mostrar vista`);
                showFights(); // Llamar a la funci√≥n original corregida
            } else {
                console.log('‚ùå No hay peleas en vivo - Mostrando mensaje apropiado');
                hideAllViews();
                document.getElementById('liveFight').classList.add('active');
                showNoLiveFightsMessage();
            }
        });
    }

    function debugFechas() {
        const ahora = new Date();

        console.log('üïê DEBUG DE FECHAS:');
        console.log('  new Date():', ahora);
        console.log('  toISOString():', ahora.toISOString());
        console.log('  toString():', ahora.toString());
        console.log('  getTime():', ahora.getTime());
        console.log('  getTimezoneOffset():', ahora.getTimezoneOffset(), 'minutos');
        console.log('  Zona horaria:', Intl.DateTimeFormat().resolvedOptions().timeZone);

        // Probar parsing
        const isoString = ahora.toISOString();
        const parsed = new Date(isoString);
        console.log('  Parsed back:', parsed.toISOString());
        console.log('  ¬øSon iguales?:', ahora.getTime() === parsed.getTime());
    }

    async function crearPeleasDePruebaCorregida() {
        if (!currentUser || currentUser.rol !== 'admin') {
            console.error('‚ùå Solo los administradores pueden crear peleas de prueba');
            showToast('Solo los administradores pueden crear peleas de prueba', 'error');
            return;
        }

        try {
            console.log('üß™ Creando peleas de prueba con fechas corregidas...');

            // Obtener eventos y luchadores disponibles
            const [eventosRes, luchadoresRes] = await Promise.all([
                authenticatedFetch(`${API_BASE}/eventos`),
                authenticatedFetch(`${API_BASE}/luchadores`)
            ]);

            if (!eventosRes.ok || !luchadoresRes.ok) {
                throw new Error('Error obteniendo datos necesarios');
            }

            const eventos = await eventosRes.json();
            const luchadores = await luchadoresRes.json();

            if (eventos.length === 0 || luchadores.length < 2) {
                console.error('‚ùå Necesitas al menos 1 evento y 2 luchadores para crear peleas de prueba');
                showToast('Necesitas al menos 1 evento y 2 luchadores', 'error');
                return;
            }

            const ahora = new Date();
            const eventoId = eventos[0].id;
            const luchador1 = luchadores[0].id;
            const luchador2 = luchadores[1].id;

            console.log(`üìã Usando evento ID: ${eventoId}, luchadores: ${luchador1}, ${luchador2}`);
            console.log(`üïê Hora actual: ${ahora.toISOString()}`);

            // CORREGIDO: Usar formato ISO consistente
            // Pelea EN VIVO (empez√≥ hace 1 hora)
            const fechaEnVivo = new Date(ahora.getTime() - 60 * 60 * 1000);
            const peleaEnVivo = {
                eventoId: eventoId,
                luchadorAzulId: luchador1,
                luchadorRojoId: luchador2,
                fecha: fechaEnVivo.toISOString(), // Formato ISO completo
                finalizada: false
            };

            // Pelea FUTURA (en 2 horas)
            const fechaFutura = new Date(ahora.getTime() + 2 * 60 * 60 * 1000);
            const peleaFutura = {
                eventoId: eventoId,
                luchadorAzulId: luchador2,
                luchadorRojoId: luchador1,
                fecha: fechaFutura.toISOString(), // Formato ISO completo
                finalizada: false
            };

            // Pelea FINALIZADA (hace 1 d√≠a)
            const fechaFinalizada = new Date(ahora.getTime() - 24 * 60 * 60 * 1000);
            const peleaFinalizada = {
                eventoId: eventoId,
                luchadorAzulId: luchador1,
                luchadorRojoId: luchador2,
                fecha: fechaFinalizada.toISOString(), // Formato ISO completo
                finalizada: true
            };

            console.log('üìÖ Fechas de las peleas:');
            console.log(`  EN VIVO: ${fechaEnVivo.toISOString()} (hace 1 hora)`);
            console.log(`  FUTURA: ${fechaFutura.toISOString()} (en 2 horas)`);
            console.log(`  FINALIZADA: ${fechaFinalizada.toISOString()} (hace 1 d√≠a)`);

            // Crear las peleas
            const peleasPrueba = [
                { data: peleaEnVivo, descripcion: 'EN VIVO (empez√≥ hace 1 hora)' },
                { data: peleaFutura, descripcion: 'FUTURA (en 2 horas)' },
                { data: peleaFinalizada, descripcion: 'FINALIZADA (hace 1 d√≠a)' }
            ];

            console.log('üèóÔ∏è Creando peleas...');
            let exitosas = 0;

            for (const pelea of peleasPrueba) {
                try {
                    console.log(`üìù Creando pelea ${pelea.descripcion}...`);

                    const response = await authenticatedFetch(`${API_BASE}/peleas`, {
                        method: 'POST',
                        body: JSON.stringify(pelea.data)
                    });

                    if (response.ok) {
                        const created = await response.json();
                        console.log(`‚úÖ Pelea ${pelea.descripcion} creada:`, created);
                        exitosas++;
                    } else {
                        const error = await response.text();
                        console.error(`‚ùå Error creando pelea ${pelea.descripcion}:`, error);
                    }
                } catch (error) {
                    console.error(`‚ùå Error creando pelea ${pelea.descripcion}:`, error);
                }

                // Peque√±a pausa entre creaciones
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            if (exitosas > 0) {
                console.log(`‚úÖ ${exitosas} peleas de prueba creadas exitosamente`);
                showToast(`${exitosas} peleas de prueba creadas exitosamente`, 'success');

                // Actualizar estad√≠sticas y vista
                await loadStats();
                await loadDashboardData();
            } else {
                console.error('‚ùå No se pudo crear ninguna pelea de prueba');
                showToast('No se pudo crear ninguna pelea de prueba', 'error');
            }

        } catch (error) {
            console.error('‚ùå Error creando peleas de prueba:', error);
            showToast('Error creando peleas de prueba: ' + error.message, 'error');
        }
    }

    async function crearPeleasDePrueba() {
        if (!currentUser || currentUser.rol !== 'admin') {
            console.error('‚ùå Solo los administradores pueden crear peleas de prueba');
            showToast('Solo los administradores pueden crear peleas de prueba', 'error');
            return;
        }

        try {
            console.log('üß™ Creando peleas de prueba...');

            // Obtener eventos y luchadores disponibles
            const [eventosRes, luchadoresRes] = await Promise.all([
                authenticatedFetch(`${API_BASE}/eventos`),
                authenticatedFetch(`${API_BASE}/luchadores`)
            ]);

            if (!eventosRes.ok || !luchadoresRes.ok) {
                throw new Error('Error obteniendo datos necesarios');
            }

            const eventos = await eventosRes.json();
            const luchadores = await luchadoresRes.json();

            if (eventos.length === 0 || luchadores.length < 2) {
                console.error('‚ùå Necesitas al menos 1 evento y 2 luchadores para crear peleas de prueba');
                showToast('Necesitas al menos 1 evento y 2 luchadores', 'error');
                return;
            }

            const ahora = new Date();
            const eventoId = eventos[0].id;
            const luchador1 = luchadores[0].id;
            const luchador2 = luchadores[1].id;

            console.log(`üìã Usando evento ID: ${eventoId}, luchadores: ${luchador1}, ${luchador2}`);

            // Pelea EN VIVO (empez√≥ hace 1 hora)
            const peleaEnVivo = {
                eventoId: eventoId,
                luchadorAzulId: luchador1,
                luchadorRojoId: luchador2,
                fecha: new Date(ahora.getTime() - 60 * 60 * 1000).toISOString(), // Hace 1 hora
                finalizada: false
            };

            // Pelea FUTURA (en 2 horas)
            const peleaFutura = {
                eventoId: eventoId,
                luchadorAzulId: luchador2,
                luchadorRojoId: luchador1,
                fecha: new Date(ahora.getTime() + 2 * 60 * 60 * 1000).toISOString(), // En 2 horas
                finalizada: false
            };

            // Pelea FINALIZADA (hace 1 d√≠a)
            const peleaFinalizada = {
                eventoId: eventoId,
                luchadorAzulId: luchador1,
                luchadorRojoId: luchador2,
                fecha: new Date(ahora.getTime() - 24 * 60 * 60 * 1000).toISOString(), // Hace 1 d√≠a
                finalizada: true
            };

            // Crear las peleas
            const peleasPrueba = [
                { data: peleaEnVivo, descripcion: 'EN VIVO (empez√≥ hace 1 hora)' },
                { data: peleaFutura, descripcion: 'FUTURA (en 2 horas)' },
                { data: peleaFinalizada, descripcion: 'FINALIZADA (hace 1 d√≠a)' }
            ];

            console.log('üèóÔ∏è Creando peleas...');
            let exitosas = 0;

            for (const pelea of peleasPrueba) {
                try {
                    console.log(`üìù Creando pelea ${pelea.descripcion}...`);

                    const response = await authenticatedFetch(`${API_BASE}/peleas`, {
                        method: 'POST',
                        body: JSON.stringify(pelea.data)
                    });

                    if (response.ok) {
                        const created = await response.json();
                        console.log(`‚úÖ Pelea ${pelea.descripcion} creada:`, created);
                        exitosas++;
                    } else {
                        const error = await response.text();
                        console.error(`‚ùå Error creando pelea ${pelea.descripcion}:`, error);
                    }
                } catch (error) {
                    console.error(`‚ùå Error creando pelea ${pelea.descripcion}:`, error);
                }

                // Peque√±a pausa entre creaciones
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            if (exitosas > 0) {
                console.log(`‚úÖ ${exitosas} peleas de prueba creadas exitosamente`);
                showToast(`${exitosas} peleas de prueba creadas exitosamente`, 'success');

                // Actualizar estad√≠sticas y vista
                await loadStats();
                await loadDashboardData();
            } else {
                console.error('‚ùå No se pudo crear ninguna pelea de prueba');
                showToast('No se pudo crear ninguna pelea de prueba', 'error');
            }

        } catch (error) {
            console.error('‚ùå Error creando peleas de prueba:', error);
            showToast('Error creando peleas de prueba: ' + error.message, 'error');
        }
    }

    function getFightStatusClass(pelea) {
        if (pelea.finalizada) {
            return 'status-finished';
        }

        const fightDate = new Date(pelea.fecha);
        const now = new Date();

        if (fightDate <= now) {
            return 'status-live';
        }

        return 'status-upcoming';
    }

    function getFightStatusText(pelea) {
        if (pelea.finalizada) {
            return 'Finalizada';
        }

        const fightDate = new Date(pelea.fecha);
        const now = new Date();

        if (fightDate <= now) {
            return 'üî¥ En Vivo';
        }

        return 'Pr√≥ximamente';
    }

    async function viewEvent(eventId) {
        try {
            // Cargar informaci√≥n del evento
            const eventoResponse = await fetch(`${API_BASE}/eventos/${eventId}`, {
                headers: {
                    'Authorization': `Basic ${currentUser.credentials}`,
                    'Content-Type': 'application/json'
                }
            });

            if (!eventoResponse.ok) {
                throw new Error('Error cargando evento');
            }

            const evento = await eventoResponse.json();

            // Cargar peleas del evento
            const peleas = await loadFightsForEvent(eventId);

            // Cargar informaci√≥n de luchadores
            const luchadoresResponse = await fetch(`${API_BASE}/luchadores`, {
                headers: {
                    'Authorization': `Basic ${currentUser.credentials}`,
                    'Content-Type': 'application/json'
                }
            });

            const luchadores = luchadoresResponse.ok ? await luchadoresResponse.json() : [];

            // Mostrar modal o nueva vista con detalles del evento
            showEventDetails(evento, peleas, luchadores);

        } catch (error) {
            console.error('Error cargando detalles del evento:', error);
            showToast('Error cargando detalles del evento', 'error');
        }
    }

    function mostrarEstadoActual() {
        console.log('üìä ESTADO ACTUAL DEL SISTEMA:');
        console.log('Usuario actual:', currentUser ? currentUser.nombre : 'No logueado');
        console.log('Vista actual:', document.querySelector('.dashboard.active') ? 'Dashboard' :
            document.querySelector('.live-fight.active') ? 'Peleas en vivo' : 'Desconocida');

        testDeteccionPeleasEnVivo().then(resultado => {
            if (resultado) {
                console.log('Estado de peleas:', resultado);
            }
        });
    }

    function actualizarEstadisticasEnTiempoReal() {
        setInterval(async () => {
            try {
                await loadStats();

                // Verificar si hay nuevas peleas en vivo
                const peleasEnVivo = await loadLiveFightsTemp();

                // Actualizar el √≠cono del men√∫ si hay peleas en vivo
                const menuFights = document.querySelector('nav a[onclick="showFights()"]');
                if (menuFights) {
                    if (peleasEnVivo.length > 0) {
                        menuFights.innerHTML = '<i class="fas fa-fire" style="color: #4caf50;"></i> Peleas En Vivo <span style="background: #4caf50; color: white; border-radius: 50%; padding: 2px 6px; font-size: 0.8rem; margin-left: 0.5rem;">' + peleasEnVivo.length + '</span>';
                    } else {
                        menuFights.innerHTML = '<i class="fas fa-fire"></i> Peleas En Vivo';
                    }
                }

            } catch (error) {
                console.error('Error actualizando estad√≠sticas en tiempo real:', error);
            }
        }, 30000); // Cada 30 segundos
    }

    function showEventDetails(evento, peleas, luchadores) {
        const modal = document.createElement('div');
        modal.className = 'event-modal';
        modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 3000;
        padding: 2rem;
    `;

        const peleasHTML = peleas.length > 0
            ? peleas.map(pelea => {
                const luchadorAzul = luchadores.find(l => l.id === pelea.luchadorAzulId);
                const luchadorRojo = luchadores.find(l => l.id === pelea.luchadorRojoId);

                return `
                <div class="fight-detail-item" style="background: rgba(211, 47, 47, 0.1); padding: 1rem; border-radius: 8px; margin-bottom: 1rem; border-left: 3px solid #d32f2f;">
                    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem;">
                        <div class="fighters" style="display: flex; align-items: center; gap: 1rem; flex: 1;">
                            <div style="text-align: center;">
                                <div style="font-weight: bold; color: #2196f3;">${luchadorAzul ? luchadorAzul.nombre : 'TBD'}</div>
                                ${luchadorAzul ? `
                                    <div style="font-size: 0.8rem; color: #ccc;">${luchadorAzul.nacionalidad || ''}</div>
                                    <div style="font-size: 0.8rem; color: #ccc;">${luchadorAzul.historial || ''}</div>
                                ` : ''}
                            </div>
                            <div style="font-size: 1.5rem; color: #d32f2f; font-weight: bold;">VS</div>
                            <div style="text-align: center;">
                                <div style="font-weight: bold; color: #d32f2f;">${luchadorRojo ? luchadorRojo.nombre : 'TBD'}</div>
                                ${luchadorRojo ? `
                                    <div style="font-size: 0.8rem; color: #ccc;">${luchadorRojo.nacionalidad || ''}</div>
                                    <div style="font-size: 0.8rem; color: #ccc;">${luchadorRojo.historial || ''}</div>
                                ` : ''}
                            </div>
                        </div>
                        <div style="text-align: right;">
                            <div class="fight-status ${getFightStatusClass(pelea)}" style="padding: 0.5rem 1rem; border-radius: 20px; font-size: 0.9rem; font-weight: bold; margin-bottom: 0.5rem;">
                                ${getFightStatusText(pelea)}
                            </div>
                            <div style="font-size: 0.8rem; color: #ccc;">
                                ${formatDateTime(pelea.fecha)}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            }).join('')
            : '<p style="text-align: center; color: #ccc; padding: 2rem;">No hay peleas programadas para este evento</p>';

        modal.innerHTML = `
        <div style="background: linear-gradient(145deg, #1a1f2e, #2d1b2e); border-radius: 20px; max-width: 800px; width: 100%; max-height: 80vh; overflow-y: auto; border: 2px solid #d32f2f;">
            <div style="background: linear-gradient(45deg, #d32f2f, #f57c00); padding: 2rem; text-align: center; border-radius: 18px 18px 0 0;">
                <h2 style="margin: 0; font-size: 2rem;">${evento.nombre}</h2>
                <p style="margin: 0.5rem 0 0 0; opacity: 0.9;">
                    <i class="fas fa-calendar"></i> ${formatDate(evento.fecha)} |
                    <i class="fas fa-map-marker-alt"></i> ${evento.ubicacion || 'Ubicaci√≥n por definir'}
                </p>
            </div>
            <div style="padding: 2rem;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2rem;">
                    <h3 style="color: #d32f2f; margin: 0;"><i class="fas fa-fist-raised"></i> Peleas Programadas (${peleas.length})</h3>
                    <button onclick="this.parentElement.parentElement.parentElement.remove()" style="background: #666; border: none; color: white; padding: 0.5rem 1rem; border-radius: 5px; cursor: pointer;">
                        <i class="fas fa-times"></i> Cerrar
                    </button>
                </div>
                <div class="fights-list">
                    ${peleasHTML}
                </div>
                ${currentUser.rol === 'admin' ? `
                    <div style="text-align: center; margin-top: 2rem; padding-top: 2rem; border-top: 1px solid #404040;">
                        <button class="btn" onclick="addFightToEvent(${evento.id})" style="margin-right: 1rem;">
                            <i class="fas fa-plus"></i> Agregar Pelea
                        </button>
                        <button class="btn btn-secondary" onclick="editEvent(${evento.id})">
                            <i class="fas fa-edit"></i> Editar Evento
                        </button>
                    </div>
                ` : ''}
            </div>
        </div>
    `;

        document.body.appendChild(modal);

        // Cerrar modal al hacer clic fuera
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.remove();
            }
        });
    }

    function formatDateTime(dateString) {
        const date = new Date(dateString);
        return date.toLocaleString('es-ES', {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
    }

    function addFightToEvent(eventoId) {
        if (currentUser.rol !== 'admin') {
            showToast('Solo los administradores pueden agregar peleas', 'error');
            return;
        }

        // Aqu√≠ podr√≠as abrir un modal para crear una nueva pelea
        showToast(`Funci√≥n para agregar pelea al evento ${eventoId} - En desarrollo`, 'success');
    }



    // FUNCI√ìN HELPER PARA OBTENER LUCHADORES DEL MAIN EVENT
    function getMainEventFighters(eventoId, luchadores) {
        // Para UFC 317, buscar Topuria vs Oliveira
        const topuria = luchadores.find(l => l.nombre === 'Ilia Topuria');
        const oliveira = luchadores.find(l => l.nombre === 'Charles Oliveira');

        if (topuria && oliveira) {
            return {
                fighter1: topuria,
                fighter2: oliveira
            };
        }

        // Para otros eventos, tomar los primeros dos luchadores disponibles
        if (luchadores.length >= 2) {
            return {
                fighter1: luchadores[0],
                fighter2: luchadores[1]
            };
        }

        return null;
    }

    // ACTUALIZAR LA FUNCI√ìN loadEvents PARA USAR LA NUEVA FUNCI√ìN
    async function loadEvents() {
        try {
            console.log('üìÖ Cargando eventos...');

            const response = await fetch(`${API_BASE}/eventos`, {
                headers: {
                    'Authorization': `Basic ${currentUser.credentials}`,
                    'Content-Type': 'application/json'
                }
            });

            if (response.ok) {
                const eventos = await response.json();
                console.log('üìÖ Eventos cargados:', eventos.length, eventos);

                document.getElementById('totalEvents').textContent = eventos.length;

                // Usar la funci√≥n actualizada que carga peleas reales
                await renderEventsWithFighters(eventos);
            } else {
                console.error('‚ùå Error HTTP cargando eventos:', response.status, response.statusText);
                throw new Error('Error cargando eventos');
            }
        } catch (error) {
            console.error('‚ùå Error loading events:', error);
            document.getElementById('totalEvents').textContent = '0';
            await renderEventsWithFighters([]);
        }
    }

    function debugPeleasEnVivo() {
        console.log('üß™ DEBUG: Analizando detecci√≥n de peleas en vivo...');

        loadLiveFightsTemp().then(peleas => {
            console.log('üìä Resultado del debug:', peleas);

            if (peleas.length > 0) {
                console.log('‚úÖ Peleas en vivo encontradas correctamente');
                console.log('üìù Para probar la vista, ejecuta: showFights()');
            } else {
                console.log('‚ùå No se encontraron peleas en vivo');
                console.log('üí° Sugerencia: Ejecuta crearPeleasDePrueba() para crear peleas de prueba');
            }
        });
    }

    function debugPeleas() {
        console.log('üîß Iniciando debug de peleas...');

        // Verificar endpoint de todas las peleas
        fetch(`${API_BASE}/peleas`, {
            headers: {
                'Authorization': `Basic ${currentUser.credentials}`,
                'Content-Type': 'application/json'
            }
        })
            .then(response => response.json())
            .then(peleas => {
                console.log('üìã TODAS LAS PELEAS en BD:', peleas);

                const peleasEnVivo = peleas.filter(p => !p.finalizada);
                const peleasFinalizadas = peleas.filter(p => p.finalizada);

                console.log('üî¥ Peleas EN VIVO (finalizada=false):', peleasEnVivo);
                console.log('üèÅ Peleas FINALIZADAS (finalizada=true):', peleasFinalizadas);

                console.log('üìä Resumen:');
                console.log(`  - Total peleas: ${peleas.length}`);
                console.log(`  - En vivo: ${peleasEnVivo.length}`);
                console.log(`  - Finalizadas: ${peleasFinalizadas.length}`);
            })
            .catch(error => console.error('‚ùå Error en debug:', error));
    }


    function setupEventListeners() {
        // Auth forms
        document.getElementById('loginForm').addEventListener('submit', handleLogin);
        document.getElementById('registerForm').addEventListener('submit', handleRegister);
    }

    function checkAuthStatus() {
        const savedUser = localStorage.getItem('currentUser');
        if (savedUser) {
            currentUser = JSON.parse(savedUser);
            showApp();
            loadDashboardData();
        } else {
            showAuthModal();
        }
    }

    function handleWebSocketMessage(message) {
        console.log('üì® Mensaje WebSocket recibido:', message);

        if (message.type === 'fight-stats') {
            const data = message.data;
            console.log('üìä Datos de pelea del WebSocket:', data);

            // PROBLEMA DETECTADO: El WebSocket env√≠a datos simulados
            // SOLUCI√ìN: Ignorar datos del WebSocket y usar datos reales de la BD
            console.log('‚ö†Ô∏è Ignorando datos del WebSocket - usando datos reales de la BD');

            // En lugar de usar los datos del WebSocket, refrescar desde la BD
            if (currentFightData) {
                loadRealFightStatistics(
                    currentFightData.peleaId,
                    currentFightData.luchadorAzulId,
                    currentFightData.luchadorRojoId
                );
            }
        }
    }

    async function displayFightInfoWithPolling(pelea) {
        try {
            console.log('ü•ä Mostrando pelea con polling de datos reales...');

            // Guardar informaci√≥n de la pelea actual
            currentFightData = {
                peleaId: pelea.id,
                luchadorAzulId: pelea.luchadorAzulId,
                luchadorRojoId: pelea.luchadorRojoId
            };

            // Mostrar informaci√≥n b√°sica de la pelea (como antes)
            await displayFightInfo(pelea);

            // DESCONECTAR WEBSOCKET para evitar conflictos
            if (liveWebSocket && liveWebSocket.isConnected) {
                console.log('üîå Desconectando WebSocket para usar datos reales...');
                liveWebSocket.disconnect();
            }

            // INICIAR POLLING DE DATOS REALES cada 5 segundos
            console.log('üîÑ Iniciando polling de datos reales cada 5 segundos...');
            startSimplePolling(pelea.id, pelea.luchadorAzulId, pelea.luchadorRojoId);

        } catch (error) {
            console.error('‚ùå Error en displayFightInfoWithPolling:', error);
        }
    }

    function startSimplePolling(peleaId, luchadorAzulId, luchadorRojoId) {
        console.log(`üîÑ INICIANDO polling simple para pelea ${peleaId}`);

        // 1. PARAR TODO lo anterior
        stopSimplePolling();

        // 2. Marcar como activo
        isPollingActive = true;
        requestInProgress = false;

        // 3. Funci√≥n de actualizaci√≥n simple
        const updateData = async () => {
            // Si no est√° activo, salir
            if (!isPollingActive) {
                console.log('üõë Polling desactivado, saliendo...');
                return;
            }

            // Si hay request en progreso, esperar
            if (requestInProgress) {
                console.log('‚è≥ Request en progreso, saltando...');
                return;
            }

            try {
                console.log('üìä Actualizando datos simples...');
                requestInProgress = true;

                // Request simple CON timeout manual
                const response = await Promise.race([
                    authenticatedFetch(`${API_BASE}/estadisticas`),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 8000))
                ]);

                if (!response.ok) throw new Error('Response not ok');

                const stats = await response.json();

                // Procesar solo si seguimos activos
                if (isPollingActive) {
                    updateUISimple(stats, peleaId, luchadorAzulId, luchadorRojoId);
                }

            } catch (error) {
                console.error('‚ùå Error simple:', error.message);
            } finally {
                requestInProgress = false;
            }
        };

        // 4. Ejecutar inmediatamente
        updateData();

        // 5. Programar siguientes ejecuciones (INTERVALO LARGO)
        pollingTimer = setInterval(() => {
            if (isPollingActive && !requestInProgress) {
                updateData();
            }
        }, 15000); // ‚úÖ 15 SEGUNDOS - MUY CONSERVADOR

        console.log('‚úÖ Polling simple iniciado con intervalo de 15s');
    }


    async function loadRealFightStatisticsOptimized(peleaId, luchadorAzulId, luchadorRojoId) {
        if (isLoadingStats) {
            console.log('‚è≥ Ya hay una carga en progreso, ignorando...');
            return;
        }

        isLoadingStats = true;

        try {
            console.log(`üìä Cargando stats OPTIMIZADAS: Pelea ${peleaId}, Azul ${luchadorAzulId}, Rojo ${luchadorRojoId}`);

            // ‚úÖ TIMEOUT DE 5 SEGUNDOS PARA REQUESTS
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 5000);

            const response = await authenticatedFetch(`${API_BASE}/estadisticas`, {
                signal: controller.signal
            });

            clearTimeout(timeoutId);

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const todasEstadisticas = await response.json();

            // Filtrar estad√≠sticas de esta pelea espec√≠fica
            const statsAzul = todasEstadisticas.filter(s =>
                s.peleaId === peleaId && s.luchadorId === luchadorAzulId);
            const statsRojo = todasEstadisticas.filter(s =>
                s.peleaId === peleaId && s.luchadorId === luchadorRojoId);

            // Calcular totales
            const totalesAzul = calcularTotales(statsAzul);
            const totalesRojo = calcularTotales(statsRojo);

            console.log(`üìà Stats calculadas - Azul: ${totalesAzul.golpes} golpes, Rojo: ${totalesRojo.golpes} golpes`);

            // ‚úÖ SOLO ACTUALIZAR SI HAY CAMBIOS
            const newData = {
                azul: totalesAzul,
                rojo: totalesRojo,
                timestamp: Date.now()
            };

            if (!currentFightData || hasDataChanged(currentFightData, newData)) {
                console.log('üìä Datos han cambiado, actualizando UI...');
                currentFightData = newData;
                updateStatsDisplayOptimized(totalesAzul, totalesRojo);

                // Cargar probabilidades solo si hay cambios
                await loadProbabilitiesOptimized(peleaId, luchadorAzulId, luchadorRojoId);
            } else {
                console.log('üìä Datos sin cambios, UI sin actualizar');
            }

        } catch (error) {
            if (error.name === 'AbortError') {
                console.warn('‚è∞ Request de estad√≠sticas cancelado por timeout');
            } else {
                console.error('‚ùå Error cargando estad√≠sticas optimizadas:', error);
            }
        } finally {
            isLoadingStats = false;
        }
    }

    function hasDataChanged(oldData, newData) {
        if (!oldData) return true;

        return (
            oldData.azul.golpes !== newData.azul.golpes ||
            oldData.azul.derribos !== newData.azul.derribos ||
            oldData.azul.controlJaula !== newData.azul.controlJaula ||
            oldData.rojo.golpes !== newData.rojo.golpes ||
            oldData.rojo.derribos !== newData.rojo.derribos ||
            oldData.rojo.controlJaula !== newData.rojo.controlJaula
        );
    }

    function updateStatsDisplayOptimized(totalesAzul, totalesRojo) {
        try {
            // Verificar que estamos en la vista correcta
            if (!document.querySelector('.live-stats')) {
                console.log('‚ÑπÔ∏è No estamos en vista de peleas en vivo, saltando actualizaci√≥n UI');
                return;
            }

            // Actualizar con animaci√≥n suave
            const elements = {
                blueStrikes: document.querySelector('.stat-row:nth-child(1) .stat-blue'),
                redStrikes: document.querySelector('.stat-row:nth-child(1) .stat-red'),
                blueTakedowns: document.querySelector('.stat-row:nth-child(2) .stat-blue'),
                redTakedowns: document.querySelector('.stat-row:nth-child(2) .stat-red'),
                blueCageControl: document.querySelector('.stat-row:nth-child(3) .stat-blue'),
                redCageControl: document.querySelector('.stat-row:nth-child(3) .stat-red'),
                fightStatus: document.querySelector('.fight-status')
            };

            // ‚úÖ ANIMACI√ìN SUAVE AL ACTUALIZAR
            Object.values(elements).forEach(el => {
                if (el) el.classList.add('updating');
            });

            setTimeout(() => {
                if (elements.blueStrikes) elements.blueStrikes.textContent = totalesAzul.golpes;
                if (elements.redStrikes) elements.redStrikes.textContent = totalesRojo.golpes;
                if (elements.blueTakedowns) elements.blueTakedowns.textContent = totalesAzul.derribos;
                if (elements.redTakedowns) elements.redTakedowns.textContent = totalesRojo.derribos;
                if (elements.blueCageControl) elements.blueCageControl.textContent = formatTime(totalesAzul.controlJaula);
                if (elements.redCageControl) elements.redCageControl.textContent = formatTime(totalesRojo.controlJaula);

                const currentRound = Math.max(totalesAzul.round, totalesRojo.round);
                if (elements.fightStatus) {
                    elements.fightStatus.textContent = `üî¥ EN VIVO - Round ${currentRound}`;
                }

                // Remover animaci√≥n
                Object.values(elements).forEach(el => {
                    if (el) el.classList.remove('updating');
                });

                console.log('‚úÖ UI actualizada exitosamente');
            }, 150);

        } catch (error) {
            console.error('‚ùå Error actualizando UI optimizada:', error);
        }
    }

    async function loadProbabilitiesOptimized(peleaId, luchadorAzulId, luchadorRojoId) {
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 3000);

            const response = await authenticatedFetch(`${API_BASE}/probabilidades`, {
                signal: controller.signal
            });

            clearTimeout(timeoutId);

            if (!response.ok) return;

            const probabilidades = await response.json();

            const probAzul = probabilidades
                .filter(p => p.peleaId === peleaId && p.luchadorId === luchadorAzulId)
                .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))[0];

            const probRojo = probabilidades
                .filter(p => p.peleaId === peleaId && p.luchadorId === luchadorRojoId)
                .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))[0];

            let blueProbability = probAzul ? Math.round(probAzul.probabilidad) : 50;
            let redProbability = probRojo ? Math.round(probRojo.probabilidad) : (100 - blueProbability);

            // Actualizar UI de probabilidades
            const blueProb = document.querySelector('.prob-values .stat-blue');
            const redProb = document.querySelector('.prob-values .stat-red');
            const blueBar = document.querySelector('.prob-blue');
            const redBar = document.querySelector('.prob-red');

            if (blueProb && redProb && blueBar && redBar) {
                blueProb.textContent = `${blueProbability}%`;
                redProb.textContent = `${redProbability}%`;
                blueBar.style.width = `${blueProbability}%`;
                redBar.style.width = `${redProbability}%`;
            }

        } catch (error) {
            if (error.name !== 'AbortError') {
                console.error('‚ùå Error cargando probabilidades:', error);
            }
        }
    }

    function stopSimplePolling() {
        console.log('‚èπÔ∏è PARANDO polling simple');

        // 1. Desactivar flag
        isPollingActive = false;

        // 2. Limpiar timer
        if (pollingTimer) {
            clearInterval(pollingTimer);
            pollingTimer = null;
        }

        // 3. Reset flags
        requestInProgress = false;

        console.log('‚úÖ Polling simple DETENIDO');
    }


    function togglePolling() {
        pollingEnabled = !pollingEnabled;
        console.log(`${pollingEnabled ? '‚ñ∂Ô∏è Reanudando' : '‚è∏Ô∏è Pausando'} polling`);
        showToast(`Polling ${pollingEnabled ? 'reanudado' : 'pausado'}`, 'success');
    }

    function setPollingInterval(seconds) {
        if (liveDataInterval) {
            console.log(`üîÑ Cambiando intervalo de polling a ${seconds} segundos`);
            stopRealDataPolling();

            // Reiniciar con nuevo intervalo (esto requerir√≠a modificar startRealDataPolling)
            showToast(`Intervalo cambiado a ${seconds} segundos`, 'success');
        }
    }



    async function loadRealFightStatisticsFixed(peleaId, luchadorAzulId, luchadorRojoId) {
        try {
            console.log(`üìä Cargando stats REALES: Pelea ${peleaId}, Azul ${luchadorAzulId}, Rojo ${luchadorRojoId}`);

            // Cargar estad√≠sticas desde la API
            const statsResponse = await authenticatedFetch(`${API_BASE}/estadisticas`);
            if (!statsResponse.ok) {
                throw new Error('Error cargando estad√≠sticas');
            }

            const todasEstadisticas = await statsResponse.json();
            console.log(`üìä Total estad√≠sticas en BD: ${todasEstadisticas.length}`);

            // Filtrar estad√≠sticas de esta pelea espec√≠fica
            const statsAzul = todasEstadisticas.filter(s =>
                s.peleaId === peleaId && s.luchadorId === luchadorAzulId);
            const statsRojo = todasEstadisticas.filter(s =>
                s.peleaId === peleaId && s.luchadorId === luchadorRojoId);

            console.log(`üìä Stats encontradas - Azul: ${statsAzul.length}, Rojo: ${statsRojo.length}`);

            // Calcular totales CORRECTAMENTE
            const totalesAzul = calculateTotals(statsAzul);
            const totalesRojo = calculateTotals(statsRojo);

            console.log('üìä Totales calculados:');
            console.log('  Azul:', totalesAzul);
            console.log('  Rojo:', totalesRojo);

            // Actualizar UI con formato correcto
            updateUIWithCorrectFormat(totalesAzul, totalesRojo);

            // Cargar probabilidades
            await loadRealProbabilitiesFixed(peleaId, luchadorAzulId, luchadorRojoId, totalesAzul, totalesRojo);

            console.log('‚úÖ Stats REALES actualizadas correctamente');

        } catch (error) {
            console.error('‚ùå Error cargando estad√≠sticas reales:', error);
            showErrorInUI('Error cargando estad√≠sticas: ' + error.message);
        }
    }

    function calculateTotals(stats) {
        if (!stats || stats.length === 0) {
            return {
                golpes: 0,
                derribos: 0,
                controlJaula: 0,
                round: 1
            };
        }

        return {
            golpes: stats.reduce((sum, s) => sum + (parseInt(s.golpesConectados) || 0), 0),
            derribos: stats.reduce((sum, s) => sum + (parseInt(s.derribos) || 0), 0),
            controlJaula: stats.reduce((sum, s) => sum + (parseInt(s.controlJaulaSegundos) || 0), 0),
            round: Math.max(...stats.map(s => parseInt(s.round) || 1))
        };
    }

    function updateUIWithCorrectFormat(totalesAzul, totalesRojo) {
        const elementos = {
            blueStrikes: document.getElementById('blueStrikes'),
            redStrikes: document.getElementById('redStrikes'),
            blueTakedowns: document.getElementById('blueTakedowns'),
            redTakedowns: document.getElementById('redTakedowns'),
            blueCageControl: document.getElementById('blueCageControl'),
            redCageControl: document.getElementById('redCageControl'),
            currentRound: document.getElementById('currentRound'),
            lastUpdate: document.getElementById('lastUpdate')
        };

        console.log('üîç Actualizando elementos UI:');

        // CORREGIDO: Mostrar n√∫meros, no tiempo para golpes y derribos
        if (elementos.blueStrikes) {
            elementos.blueStrikes.textContent = totalesAzul.golpes;
            console.log(`  Golpes Azul: ${totalesAzul.golpes}`);
        }

        if (elementos.redStrikes) {
            elementos.redStrikes.textContent = totalesRojo.golpes;
            console.log(`  Golpes Rojo: ${totalesRojo.golpes}`);
        }

        if (elementos.blueTakedowns) {
            elementos.blueTakedowns.textContent = totalesAzul.derribos;
            console.log(`  Derribos Azul: ${totalesAzul.derribos}`);
        }

        if (elementos.redTakedowns) {
            elementos.redTakedowns.textContent = totalesRojo.derribos;
            console.log(`  Derribos Rojo: ${totalesRojo.derribos}`);
        }

        // CORREGIDO: Solo el control de jaula se muestra como tiempo
        if (elementos.blueCageControl) {
            const tiempoAzul = formatTime(totalesAzul.controlJaula);
            elementos.blueCageControl.textContent = tiempoAzul;
            console.log(`  Control Azul: ${tiempoAzul} (${totalesAzul.controlJaula}s)`);
        }

        if (elementos.redCageControl) {
            const tiempoRojo = formatTime(totalesRojo.controlJaula);
            elementos.redCageControl.textContent = tiempoRojo;
            console.log(`  Control Rojo: ${tiempoRojo} (${totalesRojo.controlJaula}s)`);
        }

        if (elementos.currentRound) {
            const roundActual = Math.max(totalesAzul.round, totalesRojo.round);
            elementos.currentRound.textContent = roundActual;
            console.log(`  Round: ${roundActual}`);
        }

        if (elementos.lastUpdate) {
            elementos.lastUpdate.textContent = `Actualizado: ${new Date().toLocaleTimeString('es-ES')}`;
            elementos.lastUpdate.style.color = '#4caf50';
        }
    }

    async function loadRealProbabilitiesFixed(peleaId, luchadorAzulId, luchadorRojoId, totalesAzul, totalesRojo) {
        try {
            console.log('üéØ Cargando probabilidades...');

            const probResponse = await authenticatedFetch(`${API_BASE}/probabilidades`);
            if (!probResponse.ok) {
                console.log('‚ö†Ô∏è No se pudieron cargar probabilidades, calculando...');
                calculateAndDisplayProbabilities(totalesAzul, totalesRojo);
                return;
            }

            const todasProbabilidades = await probResponse.json();

            // Buscar probabilidades m√°s recientes
            const probAzul = todasProbabilidades
                .filter(p => p.peleaId === peleaId && p.luchadorId === luchadorAzulId)
                .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))[0];

            const probRojo = todasProbabilidades
                .filter(p => p.peleaId === peleaId && p.luchadorId === luchadorRojoId)
                .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))[0];

            let blueProbability, redProbability;

            if (probAzul && probRojo) {
                // Usar probabilidades de la BD
                blueProbability = Math.round(parseFloat(probAzul.probabilidad));
                redProbability = Math.round(parseFloat(probRojo.probabilidad));
                console.log('üéØ Usando probabilidades de BD');
            } else {
                // Calcular bas√°ndose en estad√≠sticas
                const result = calculateProbabilities(totalesAzul, totalesRojo);
                blueProbability = result.blue;
                redProbability = result.red;
                console.log('üéØ Calculando probabilidades');
            }

            updateProbabilityDisplay(blueProbability, redProbability);

        } catch (error) {
            console.error('‚ùå Error cargando probabilidades:', error);
            calculateAndDisplayProbabilities(totalesAzul, totalesRojo);
        }
    }

    function calculateProbabilities(totalesAzul, totalesRojo) {
        const scoreAzul = totalesAzul.golpes + (totalesAzul.derribos * 5) + (totalesAzul.controlJaula / 60);
        const scoreRojo = totalesRojo.golpes + (totalesRojo.derribos * 5) + (totalesRojo.controlJaula / 60);
        const total = scoreAzul + scoreRojo;

        if (total === 0) {
            return { blue: 50, red: 50 };
        }

        const blue = Math.round((scoreAzul / total) * 100);
        const red = 100 - blue;

        return { blue, red };
    }

    function updateProbabilityDisplay(blueProbability, redProbability) {
        console.log(`üéØ Actualizando probabilidades: Azul ${blueProbability}%, Rojo ${redProbability}%`);

        const probElements = {
            probBlueText: document.getElementById('probBlueText'),
            probRedText: document.getElementById('probRedText'),
            probBlueBar: document.getElementById('probBlueBar'),
            probRedBar: document.getElementById('probRedBar')
        };

        if (probElements.probBlueText) probElements.probBlueText.textContent = `${blueProbability}%`;
        if (probElements.probRedText) probElements.probRedText.textContent = `${redProbability}%`;
        if (probElements.probBlueBar) probElements.probBlueBar.style.width = `${blueProbability}%`;
        if (probElements.probRedBar) probElements.probRedBar.style.width = `${redProbability}%`;
    }

    function showErrorInUI(message) {
        const lastUpdate = document.getElementById('lastUpdate');
        if (lastUpdate) {
            lastUpdate.textContent = message;
            lastUpdate.style.color = '#f44336';
        }
    }

    function calculateAndDisplayProbabilities(totalesAzul, totalesRojo) {
        const result = calculateProbabilities(totalesAzul, totalesRojo);
        updateProbabilityDisplay(result.blue, result.red);
    }

    window.loadRealFightStatistics = loadRealFightStatisticsFixed;
    window.displayFightInfo = displayFightInfoWithPolling;

    function showAuthModal() {
        document.getElementById('authModal').style.display = 'flex';
    }

    function cleanupSimple() {
        console.log('üßπ Limpieza simple');
        stopSimplePolling();

        if (liveWebSocket) {
            liveWebSocket.disconnect();
            liveWebSocket = null;
        }
    }

    const originalShowDashboard = window.showDashboardSimple;
    window.showDashboard = function() {
        cleanupSimple();
        showDashboardSimple();
    };

    function createEnhancedControlPanel(peleaId, luchadorAzulId, luchadorRojoId) {
        return `
        <div style="text-align: center; margin-top: 2rem; padding: 1.5rem; background: rgba(211, 47, 47, 0.1); border-radius: 10px; border: 1px solid #d32f2f;">
            <h4 style="color: #d32f2f; margin-bottom: 1.5rem;">
                <i class="fas fa-tools"></i> Panel de Control en Vivo
            </h4>

            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1rem;">
                <div style="background: rgba(33, 150, 243, 0.1); padding: 1rem; border-radius: 8px; border-left: 4px solid #2196f3;">
                    <h5 style="color: #2196f3; margin-bottom: 0.5rem;">Luchador Azul</h5>
                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; justify-content: center;">
                        <button class="btn btn-secondary" onclick="agregarGolpes(${peleaId}, ${luchadorAzulId}, 3)" style="font-size: 0.8rem; padding: 0.3rem 0.6rem;">
                            +3 Golpes
                        </button>
                        <button class="btn btn-secondary" onclick="agregarDerribo(${peleaId}, ${luchadorAzulId})" style="font-size: 0.8rem; padding: 0.3rem 0.6rem;">
                            +Derribo
                        </button>
                    </div>
                </div>

                <div style="background: rgba(211, 47, 47, 0.1); padding: 1rem; border-radius: 8px; border-left: 4px solid #d32f2f;">
                    <h5 style="color: #d32f2f; margin-bottom: 0.5rem;">Luchador Rojo</h5>
                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; justify-content: center;">
                        <button class="btn btn-secondary" onclick="agregarGolpes(${peleaId}, ${luchadorRojoId}, 3)" style="font-size: 0.8rem; padding: 0.3rem 0.6rem;">
                            +3 Golpes
                        </button>
                        <button class="btn btn-secondary" onclick="agregarDerribo(${peleaId}, ${luchadorRojoId})" style="font-size: 0.8rem; padding: 0.3rem 0.6rem;">
                            +Derribo
                        </button>
                    </div>
                </div>
            </div>

            <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap; margin-bottom: 1rem;">
                <button class="btn" onclick="simularNuevoRound(${peleaId}, ${luchadorAzulId}, ${luchadorRojoId}, 3)" style="background: linear-gradient(45deg, #ff9800, #ffb74d);">
                    <i class="fas fa-forward"></i> Simular Round 3
                </button>
                <button class="btn btn-secondary" onclick="loadRealFightStatisticsFixed(${peleaId}, ${luchadorAzulId}, ${luchadorRojoId})">
                    <i class="fas fa-sync"></i> Actualizar Ahora
                </button>
                <button class="btn btn-secondary" onclick="debugEstadisticasActual()">
                    <i class="fas fa-bug"></i> Debug Stats
                </button>
            </div>

            <div style="display: flex; gap: 1rem; justify-content: center; align-items: center; flex-wrap: wrap; margin-bottom: 1rem;">
                <span style="color: #ccc; font-size: 0.9rem;">Probabilidades:</span>
                <button class="btn btn-secondary" onclick="actualizarProbabilidades(${peleaId}, ${luchadorAzulId}, ${luchadorRojoId}, 80, 20)" style="font-size: 0.8rem; padding: 0.3rem 0.6rem;">
                    80% vs 20%
                </button>
                <button class="btn btn-secondary" onclick="actualizarProbabilidades(${peleaId}, ${luchadorAzulId}, ${luchadorRojoId}, 60, 40)" style="font-size: 0.8rem; padding: 0.3rem 0.6rem;">
                    60% vs 40%
                </button>
                <button class="btn btn-secondary" onclick="actualizarProbabilidades(${peleaId}, ${luchadorAzulId}, ${luchadorRojoId}, 45, 55)" style="font-size: 0.8rem; padding: 0.3rem 0.6rem;">
                    45% vs 55%
                </button>
            </div>

            <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #555; font-size: 0.85rem; color: #ccc;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span>Polling activo: <span style="color: #4caf50;">‚óè</span> Cada 5s</span>
                    <span>Pelea ID: ${peleaId}</span>
                </div>
            </div>
        </div>
    `;
    }

    function hideAuthModal() {
        document.getElementById('authModal').style.display = 'none';
    }

    function showApp() {
        hideAuthModal();
        updateUserInfo();
        showDashboardSimple;
    }

    function updateUserInfo() {
        if (currentUser) {
            document.getElementById('userName').textContent = currentUser.nombre;
            document.getElementById('userRole').textContent = currentUser.rol.toUpperCase();
            document.getElementById('navMenu').style.display = 'flex';
            document.getElementById('userInfo').style.display = 'flex';
        }
    }

    function toggleAuthMode() {
        isLoginMode = !isLoginMode;
        const loginForm = document.getElementById('loginForm');
        const registerForm = document.getElementById('registerForm');
        const switchText = document.getElementById('authSwitchText');
        const switchLink = document.getElementById('authSwitchLink');

        if (isLoginMode) {
            loginForm.classList.remove('hidden');
            registerForm.classList.add('hidden');
            switchText.textContent = '¬øNo tienes cuenta?';
            switchLink.textContent = 'Reg√≠strate aqu√≠';
        } else {
            loginForm.classList.add('hidden');
            registerForm.classList.remove('hidden');
            switchText.textContent = '¬øYa tienes cuenta?';
            switchLink.textContent = 'Inicia sesi√≥n aqu√≠';
        }
    }

    async function handleLogin(e) {
        e.preventDefault();

        const email = document.getElementById('loginEmail').value;
        const password = document.getElementById('loginPassword').value;

        setLoadingState('login', true);

        try {
            // Crear las credenciales Basic Auth correctamente
            const credentials = btoa(`${email}:${password}`);

            console.log('üîê Intentando login para:', email);

            // Primero intentar el endpoint de autenticaci√≥n
            const response = await fetch(`${API_BASE}/auth/login`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ email, password })
            });

            if (response.ok) {
                const userData = await response.json();

                // Guardar usuario con credenciales para futuros requests
                currentUser = {
                    ...userData,
                    credentials: credentials,  // Guardar las credenciales codificadas
                    email: email,             // Asegurar que tenemos el email
                    password: password        // Solo para debugging, no recomendado en producci√≥n
                };

                localStorage.setItem('currentUser', JSON.stringify(currentUser));

                console.log('‚úÖ Login exitoso, usuario guardado:', currentUser);

                showToast('¬°Inicio de sesi√≥n exitoso!', 'success');
                showApp();
            } else {
                const error = await response.json();
                throw new Error(error.error || 'Credenciales inv√°lidas');
            }
        } catch (error) {
            console.error('‚ùå Error en login:', error);
            showToast(error.message || 'Error de inicio de sesi√≥n', 'error');
        } finally {
            setLoadingState('login', false);
        }
    }

    function verifyCredentials() {
        if (!currentUser || !currentUser.credentials) {
            console.error('‚ùå No hay credenciales v√°lidas');
            showToast('Sesi√≥n expirada, por favor inicia sesi√≥n nuevamente', 'error');
            logout();
            return false;
        }
        return true;
    }

    async function authenticatedFetch(url, options = {}) {
        if (!verifyCredentials()) {
            throw new Error('No hay credenciales v√°lidas');
        }

        const defaultOptions = {
            headers: {
                'Authorization': `Basic ${currentUser.credentials}`,
                'Content-Type': 'application/json',
                ...options.headers
            },
            ...options
        };

        console.log(`üåê Request a: ${url} con credenciales`);

        const response = await fetch(url, defaultOptions);

        if (response.status === 401) {
            console.error('‚ùå Error 401 - Credenciales inv√°lidas');
            showToast('Sesi√≥n expirada, por favor inicia sesi√≥n nuevamente', 'error');
            logout();
            throw new Error('No autorizado');
        }

        return response;
    }

    function checkAuthStatus() {
        const savedUser = localStorage.getItem('currentUser');
        if (savedUser) {
            try {
                currentUser = JSON.parse(savedUser);

                // Verificar que las credenciales est√©n presentes
                if (!currentUser.credentials) {
                    console.warn('‚ö†Ô∏è Usuario guardado sin credenciales, requiere nuevo login');
                    logout();
                    return;
                }

                console.log('‚úÖ Usuario recuperado del localStorage:', currentUser);
                showApp();
                loadDashboardData();
            } catch (error) {
                console.error('‚ùå Error parseando usuario guardado:', error);
                logout();
            }
        } else {
            console.log('‚ÑπÔ∏è No hay usuario guardado');
            showAuthModal();
        }
    }


    async function handleRegister(e) {
        e.preventDefault();

        const name = document.getElementById('registerName').value;
        const email = document.getElementById('registerEmail').value;
        const password = document.getElementById('registerPassword').value;

        setLoadingState('register', true);

        try {
            const response = await fetch(`${API_BASE}/usuarios`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    nombre: name,
                    correo: email,
                    password: password
                })
            });

            if (response.ok) {
                const result = await response.json();
                showToast('¬°Registro exitoso! Revisa tu email para la confirmaci√≥n.', 'success');

                // Switch to login form
                toggleAuthMode();

                // Pre-fill login email
                document.getElementById('loginEmail').value = email;
            } else {
                const error = await response.json();
                throw new Error(error.error || 'Error en el registro');
            }
        } catch (error) {
            showToast(error.message || 'Error de registro', 'error');
        } finally {
            setLoadingState('register', false);
        }
    }

    function setLoadingState(form, loading) {
        const button = document.getElementById(`${form}ButtonText`);
        const spinner = document.getElementById(`${form}Loading`);

        if (loading) {
            button.style.display = 'none';
            spinner.classList.remove('hidden');
        } else {
            button.style.display = 'inline';
            spinner.classList.add('hidden');
        }
    }

    function logout() {
        currentUser = null;
        localStorage.removeItem('currentUser');
        document.getElementById('navMenu').style.display = 'none';
        document.getElementById('userInfo').style.display = 'none';
        showAuthModal();
    }

    function showDashboardSimple() {
        console.log('üè† Mostrando dashboard (con limpieza)');
        cleanupSimple(); // ‚úÖ IMPORTANTE: Limpiar polling
        hideAllViews();
        document.getElementById('dashboard').classList.add('active');
        loadDashboardData();
    }

    function updateUISimple(allStats, peleaId, luchadorAzulId, luchadorRojoId) {
        try {
            // Verificar que estamos en la vista correcta
            const liveFightView = document.getElementById('liveFight');
            if (!liveFightView || !liveFightView.classList.contains('active')) {
                console.log('‚ÑπÔ∏è No estamos en vista de peleas, saltando UI');
                return;
            }

            // Filtrar stats
            const statsAzul = allStats.filter(s => s.peleaId === peleaId && s.luchadorId === luchadorAzulId);
            const statsRojo = allStats.filter(s => s.peleaId === peleaId && s.luchadorId === luchadorRojoId);

            // Calcular totales
            const azulTotal = {
                golpes: statsAzul.reduce((sum, s) => sum + (s.golpesConectados || 0), 0),
                derribos: statsAzul.reduce((sum, s) => sum + (s.derribos || 0), 0),
                control: statsAzul.reduce((sum, s) => sum + (s.controlJaulaSegundos || 0), 0)
            };

            const rojoTotal = {
                golpes: statsRojo.reduce((sum, s) => sum + (s.golpesConectados || 0), 0),
                derribos: statsRojo.reduce((sum, s) => sum + (s.derribos || 0), 0),
                control: statsRojo.reduce((sum, s) => sum + (s.controlJaulaSegundos || 0), 0)
            };

            // Actualizar UI directamente
            const elements = {
                blueStrikes: document.querySelector('.stat-row:nth-child(1) .stat-blue'),
                redStrikes: document.querySelector('.stat-row:nth-child(1) .stat-red'),
                blueTakedowns: document.querySelector('.stat-row:nth-child(2) .stat-blue'),
                redTakedowns: document.querySelector('.stat-row:nth-child(2) .stat-red'),
                blueCageControl: document.querySelector('.stat-row:nth-child(3) .stat-blue'),
                redCageControl: document.querySelector('.stat-row:nth-child(3) .stat-red')
            };

            // Actualizar solo si elementos existen
            if (elements.blueStrikes) elements.blueStrikes.textContent = azulTotal.golpes;
            if (elements.redStrikes) elements.redStrikes.textContent = rojoTotal.golpes;
            if (elements.blueTakedowns) elements.blueTakedowns.textContent = azulTotal.derribos;
            if (elements.redTakedowns) elements.redTakedowns.textContent = rojoTotal.derribos;
            if (elements.blueCageControl) elements.blueCageControl.textContent = formatTimeSimple(azulTotal.control);
            if (elements.redCageControl) elements.redCageControl.textContent = formatTimeSimple(rojoTotal.control);

            console.log(`üìä UI actualizada: Azul ${azulTotal.golpes} golpes, Rojo ${rojoTotal.golpes} golpes`);

        } catch (error) {
            console.error('‚ùå Error actualizando UI simple:', error);
        }
    }

    function getPollingStatus() {
        return {
            isPollingActive,
            requestInProgress,
            hasTimer: !!pollingTimer,
            timerInfo: pollingTimer ? 'Active' : 'None'
        };
    }

    function showEvents() {
        showDashboardSimple; // For now, same as dashboard
    }

    async function showFightsSimple() {
        console.log('üî¥ Mostrando peleas EN VIVO (versi√≥n simple)...');

        // 1. Limpiar todo anterior
        cleanupSimple();
        hideAllViews();
        document.getElementById('liveFight').classList.add('active');

        try {
            // 2. Cargar peleas en vivo
            const peleasEnVivo = await loadLiveFightsTemp();

            if (peleasEnVivo.length === 0) {
                showNoLiveFightsMessage();
                return;
            }

            // 3. Tomar primera pelea
            const pelea = peleasEnVivo[0];
            console.log(`‚úÖ Pelea en vivo encontrada: ${pelea.id}`);

            // 4. Mostrar info de la pelea
            await displayFightInfo(pelea);

            // 5. INICIAR polling simple
            startSimplePolling(pelea.id, pelea.luchadorAzulId, pelea.luchadorRojoId);

        } catch (error) {
            console.error('‚ùå Error en showFightsSimple:', error);
            showNoLiveFightsMessage();
        }
    }

    function showNoLiveFightsMessage() {
        showNoLiveFightsMessageUpdated();
    }

    function showNoLiveFightsMessageUpdated() {
        const liveFightContainer = document.getElementById('liveFight');
        liveFightContainer.innerHTML = `
        <div class="no-live-fights" style="text-align: center; padding: 4rem 2rem; color: #cccccc;">
            <button class="btn btn-secondary" onclick="showDashboardSimple" style="float: left; margin-bottom: 2rem;">
                <i class="fas fa-arrow-left"></i> Volver
            </button>
            <div style="clear: both;"></div>

            <div style="background: linear-gradient(145deg, #1a1f2e, #2d1b2e); padding: 3rem; border-radius: 20px; border: 2px solid #404040; max-width: 600px; margin: 0 auto;">
                <i class="fas fa-clock" style="font-size: 4rem; color: #666; margin-bottom: 2rem;"></i>
                <h2 style="color: #d32f2f; margin-bottom: 1rem; font-size: 2rem;">No hay peleas en vivo ahora</h2>
                <p style="font-size: 1.2rem; margin-bottom: 2rem; line-height: 1.6;">
                    No hay peleas que hayan empezado y est√©n transmitiendo en este momento.
                </p>

                <div style="background: rgba(255, 193, 7, 0.1); padding: 1.5rem; border-radius: 10px; border-left: 4px solid #ffc107; margin-bottom: 2rem;">
                    <h4 style="color: #ffc107; margin-bottom: 0.5rem;">
                        <i class="fas fa-info-circle"></i> ¬øQu√© significa "en vivo"?
                    </h4>
                    <p style="color: #cccccc; margin: 0; font-size: 0.9rem;">
                        Una pelea est√° "en vivo" solo cuando ya empez√≥ (la fecha/hora de la pelea es anterior a ahora)
                        y a√∫n no ha terminado. Las peleas programadas para el futuro aparecen como "Pr√≥ximamente".
                    </p>
                </div>

                <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap; margin-bottom: 2rem;">
                    <button class="btn" onclick="showDashboardSimple">
                        <i class="fas fa-home"></i> Dashboard
                    </button>
                    <button class="btn btn-secondary" onclick="reloadLiveFightView()">
                        <i class="fas fa-sync"></i> Verificar Peleas
                    </button>
                    ${currentUser && currentUser.rol === 'admin' ? `
                        <button class="btn" onclick="crearPeleaAhoraMismo()" style="background: linear-gradient(45deg, #4caf50, #66bb6a);">
                            <i class="fas fa-plus"></i> Crear Pelea EN VIVO
                        </button>
                    ` : ''}
                </div>

                ${currentUser && currentUser.rol === 'admin' ? `
                    <div style="background: rgba(211, 47, 47, 0.1); padding: 1.5rem; border-radius: 10px; border-left: 4px solid #d32f2f; margin-bottom: 2rem;">
                        <h4 style="color: #d32f2f; margin-bottom: 1rem;">
                            <i class="fas fa-tools"></i> Herramientas de Admin
                        </h4>
                        <div style="display: flex; gap: 0.5rem; justify-content: center; flex-wrap: wrap;">
                            <button class="btn btn-secondary" onclick="testDeteccionPeleasEnVivo()">
                                <i class="fas fa-bug"></i> Test Detecci√≥n
                            </button>
                            <button class="btn btn-secondary" onclick="debugRapido()">
                                <i class="fas fa-search"></i> Debug R√°pido
                            </button>
                        </div>
                    </div>
                ` : ''}

                <div style="margin-top: 2rem; padding-top: 2rem; border-top: 1px solid #404040; font-size: 0.9rem; color: #888;">
                    <p><strong>Para desarrolladores:</strong></p>
                    <p>‚Ä¢ <code style="background: #333; padding: 2px 6px; border-radius: 3px;">testDeteccionPeleasEnVivo()</code> - Test completo de detecci√≥n</p>
                    <p>‚Ä¢ <code style="background: #333; padding: 2px 6px; border-radius: 3px;">crearPeleaAhoraMismo()</code> - Crear pelea de prueba en vivo</p>
                    <p>‚Ä¢ <code style="background: #333; padding: 2px 6px; border-radius: 3px;">reloadLiveFightView()</code> - Recargar vista completamente</p>
                </div>
            </div>
        </div>
    `;

        // Desconectar WebSocket si est√° conectado
        if (liveWebSocket) {
            liveWebSocket.disconnect();
        }
    }


    async function loadCurrentFight() {
        try {
            // Obtener peleas no finalizadas
            const response = await fetch(`${API_BASE}/peleas`, {
                headers: {
                    'Authorization': `Basic ${currentUser.credentials}`,
                    'Content-Type': 'application/json'
                }
            });

            if (response.ok) {
                const peleas = await response.json();
                const peleasEnVivo = peleas.filter(p => !p.finalizada);

                if (peleasEnVivo.length > 0) {
                    // Tomar la primera pelea en vivo
                    const pelea = peleasEnVivo[0];
                    await displayFightInfo(pelea);
                } else {
                    // No hay peleas en vivo
                    document.querySelector('.fight-title').textContent = 'No hay peleas en vivo';
                    document.querySelector('.fight-status').textContent = 'Sin peleas activas';
                    document.querySelector('.fight-status').className = 'fight-status status-finished';
                }
            }
        } catch (error) {
            console.error('Error cargando pelea actual:', error);
            showToast('Error cargando informaci√≥n de la pelea', 'error');
        }
    }

    async function displayFightInfo(pelea) {
        try {
            console.log('ü•ä Mostrando informaci√≥n de pelea EN VIVO:', pelea);

            // Verificar que la pelea est√© realmente en vivo
            const fechaPelea = parseFechaSafe(pelea.fecha);
            const ahora = new Date();
            const estaEnVivo = fechaPelea && fechaPelea <= ahora && !pelea.finalizada;

            console.log(`üîç Verificaci√≥n de estado:`);
            console.log(`  - Fecha pelea: ${fechaPelea ? fechaPelea.toISOString() : 'INV√ÅLIDA'}`);
            console.log(`  - Hora actual: ${ahora.toISOString()}`);
            console.log(`  - Finalizada: ${pelea.finalizada}`);
            console.log(`  - ¬øEn vivo?: ${estaEnVivo}`);

            if (!estaEnVivo) {
                console.warn('‚ö†Ô∏è ADVERTENCIA: La pelea seleccionada NO est√° en vivo');
            }

            // Cargar informaci√≥n del evento
            const eventoResponse = await authenticatedFetch(`${API_BASE}/eventos/${pelea.eventoId}`);
            if (!eventoResponse.ok) {
                throw new Error('Error cargando evento');
            }
            const evento = await eventoResponse.json();

            // Cargar informaci√≥n de los luchadores
            const [luchadorAzulResponse, luchadorRojoResponse] = await Promise.all([
                authenticatedFetch(`${API_BASE}/luchadores/${pelea.luchadorAzulId}`),
                authenticatedFetch(`${API_BASE}/luchadores/${pelea.luchadorRojoId}`)
            ]);

            if (!luchadorAzulResponse.ok || !luchadorRojoResponse.ok) {
                throw new Error('Error cargando luchadores');
            }

            const luchadorAzul = await luchadorAzulResponse.json();
            const luchadorRojo = await luchadorRojoResponse.json();

            // Actualizar la UI con datos reales
            const titleElement = document.querySelector('.fight-title');
            if (titleElement) {
                titleElement.textContent = `${evento.nombre} - Pelea Principal`;
            }

            // Actualizar luchador azul
            const blueNameElement = document.querySelector('.fighters-vs .fighter-card:first-child .fighter-name');
            const blueRecordElement = document.querySelector('.fighters-vs .fighter-card:first-child .fighter-record');
            if (blueNameElement) blueNameElement.textContent = luchadorAzul.nombre;
            if (blueRecordElement) {
                blueRecordElement.innerHTML = `
                <div class="fighter-nationality">${luchadorAzul.nacionalidad || 'Internacional'}</div>
                <div class="fighter-record">${luchadorAzul.historial || 'N/A'}</div>
                <div class="fighter-weight-class">${luchadorAzul.categoriaPeso || ''}</div>
            `;
            }

            // Actualizar luchador rojo
            const redNameElement = document.querySelector('.fighters-vs .fighter-card:last-child .fighter-name');
            const redRecordElement = document.querySelector('.fighters-vs .fighter-card:last-child .fighter-record');
            if (redNameElement) redNameElement.textContent = luchadorRojo.nombre;
            if (redRecordElement) {
                redRecordElement.innerHTML = `
                <div class="fighter-nationality">${luchadorRojo.nacionalidad || 'Internacional'}</div>
                <div class="fighter-record">${luchadorRojo.historial || 'N/A'}</div>
                <div class="fighter-weight-class">${luchadorRojo.categoriaPeso || ''}</div>
            `;
            }

            // Actualizar estado de la pelea
            const statusElement = document.querySelector('.fight-status');
            if (statusElement) {
                if (estaEnVivo) {
                    statusElement.textContent = 'üî¥ EN VIVO - Transmitiendo';
                    statusElement.className = 'fight-status status-live';
                } else {
                    statusElement.textContent = `‚è∞ Programada para ${fechaPelea ? fechaPelea.toLocaleString('es-ES') : 'Fecha TBD'}`;
                    statusElement.className = 'fight-status status-upcoming';
                }
            }

            // Cargar estad√≠sticas reales
            await loadFightStatistics(pelea.id, pelea.luchadorAzulId, pelea.luchadorRojoId);

            console.log('‚úÖ Informaci√≥n de pelea actualizada correctamente');

        } catch (error) {
            console.error('‚ùå Error mostrando informaci√≥n de la pelea:', error);
            showToast('Error cargando informaci√≥n de la pelea', 'error');
        }
    }

    async function loadFightsForEvent(eventoId) {
        return await loadFightsForEventTemp(eventoId);
    }

    async function testEndpointsTemp() {
        console.log('üß™ INICIANDO TESTS TEMPORALES...');

        if (!verifyCredentials()) return;

        try {
            // Test endpoint b√°sico
            console.log('\nüîç Probando: Todas las peleas');
            const response = await authenticatedFetch(`${API_BASE}/peleas`);

            if (response.ok) {
                const peleas = await response.json();
                console.log(`‚úÖ Todas las peleas (${peleas.length}):`, peleas);

                const ahora = new Date();
                console.log('üïê Hora actual:', ahora.toISOString());

                // Analizar cada pelea
                peleas.forEach(pelea => {
                    const fechaPelea = new Date(pelea.fecha);
                    const estado = determinarEstadoPeleaReal(pelea);
                    console.log(`  - ID: ${pelea.id}, Fecha: ${fechaPelea.toISOString()}, Estado: ${estado}, Finalizada: ${pelea.finalizada}`);
                });

                // Pruebas adicionales
                const peleasEnVivo = await loadLiveFightsTemp();
                const peleasFinalizadas = await loadFinishedFightsTemp();

                console.log(`\nüìä RESUMEN:`);
                console.log(`  - Total: ${peleas.length}`);
                console.log(`  - En vivo: ${peleasEnVivo.length}`);
                console.log(`  - Finalizadas: ${peleasFinalizadas.length}`);

            } else {
                console.error(`‚ùå Error ${response.status}:`, response.statusText);
            }

        } catch (error) {
            console.error('‚ùå Error en tests:', error);
        }
    }

    // FUNCI√ìN ACTUALIZADA para ser compatible con la nueva UI
    async function loadFightStatistics(peleaId, luchadorAzulId, luchadorRojoId) {
        try {
            console.log('üìä loadFightStatistics() llamada - redirigiendo a funci√≥n real...');

            // Verificar si estamos en la nueva vista
            const newUIElements = document.getElementById('blueStrikes');

            if (newUIElements) {
                // Usar la nueva funci√≥n con UI actualizada
                console.log('‚úÖ Detectada nueva UI - usando loadRealFightStatistics()');
                await loadRealFightStatistics(peleaId, luchadorAzulId, luchadorRojoId);
            } else {
                // Intentar con la UI antigua (por compatibilidad)
                console.log('‚ö†Ô∏è UI antigua detectada - intentando compatibilidad...');

                const statsResponse = await authenticatedFetch(`${API_BASE}/estadisticas`);
                if (!statsResponse.ok) {
                    throw new Error('Error cargando estad√≠sticas');
                }

                const todasEstadisticas = await statsResponse.json();
                const statsAzul = todasEstadisticas.filter(s => s.peleaId === peleaId && s.luchadorId === luchadorAzulId);
                const statsRojo = todasEstadisticas.filter(s => s.peleaId === peleaId && s.luchadorId === luchadorRojoId);

                const totalesAzul = {
                    golpes: statsAzul.reduce((sum, s) => sum + (s.golpesConectados || 0), 0),
                    derribos: statsAzul.reduce((sum, s) => sum + (s.derribos || 0), 0),
                    controlJaula: statsAzul.reduce((sum, s) => sum + (s.controlJaulaSegundos || 0), 0),
                    round: statsAzul.length > 0 ? Math.max(...statsAzul.map(s => s.round || 1)) : 1
                };

                const totalesRojo = {
                    golpes: statsRojo.reduce((sum, s) => sum + (s.golpesConectados || 0), 0),
                    derribos: statsRojo.reduce((sum, s) => sum + (s.derribos || 0), 0),
                    controlJaula: statsRojo.reduce((sum, s) => sum + (s.controlJaulaSegundos || 0), 0),
                    round: statsRojo.length > 0 ? Math.max(...statsRojo.map(s => s.round || 1)) : 1
                };

                // Intentar actualizar elementos de UI antigua
                const elements = {
                    blueStrikes: document.querySelector('.stat-row:nth-child(1) .stat-blue'),
                    redStrikes: document.querySelector('.stat-row:nth-child(1) .stat-red'),
                    blueTakedowns: document.querySelector('.stat-row:nth-child(2) .stat-blue'),
                    redTakedowns: document.querySelector('.stat-row:nth-child(2) .stat-red'),
                    blueCageControl: document.querySelector('.stat-row:nth-child(3) .stat-blue'),
                    redCageControl: document.querySelector('.stat-row:nth-child(3) .stat-red'),
                    fightStatus: document.querySelector('.fight-status')
                };

                let updated = false;
                if (elements.blueStrikes) { elements.blueStrikes.textContent = totalesAzul.golpes; updated = true; }
                if (elements.redStrikes) { elements.redStrikes.textContent = totalesRojo.golpes; updated = true; }
                if (elements.blueTakedowns) { elements.blueTakedowns.textContent = totalesAzul.derribos; updated = true; }
                if (elements.redTakedowns) { elements.redTakedowns.textContent = totalesRojo.derribos; updated = true; }
                if (elements.blueCageControl) { elements.blueCageControl.textContent = formatTime(totalesAzul.controlJaula); updated = true; }
                if (elements.redCageControl) { elements.redCageControl.textContent = formatTime(totalesRojo.controlJaula); updated = true; }

                if (updated) {
                    console.log('‚úÖ Estad√≠sticas actualizadas en UI antigua');
                } else {
                    console.log('‚ö†Ô∏è No se encontraron elementos de UI para actualizar');
                }
            }

        } catch (error) {
            console.error('‚ùå Error en loadFightStatistics:', error);
        }
    }

    function updateMenuToUseCorrectFunction() {
        // Buscar el enlace del men√∫ de peleas en vivo
        const menuFights = document.querySelector('nav a[onclick*="showFights"]');
        if (menuFights) {
            // Cambiar el onclick para usar la funci√≥n corregida
            menuFights.setAttribute('onclick', 'showFightsWithValidation()');
            console.log('‚úÖ Men√∫ actualizado para usar funci√≥n corregida');
        }
    }

    async function showFightsWithValidation() {
        console.log('üîç Validando peleas en vivo antes de mostrar vista...');

        try {
            const peleasEnVivo = await loadLiveFightsTemp();

            if (peleasEnVivo.length > 0) {
                console.log(`‚úÖ ${peleasEnVivo.length} peleas en vivo encontradas - Mostrando vista`);
                await showFights();
            } else {
                console.log('‚ùå No hay peleas en vivo - Mostrando mensaje informativo');
                hideAllViews();
                document.getElementById('liveFight').classList.add('active');
                showNoLiveFightsMessage();
            }
        } catch (error) {
            console.error('‚ùå Error validando peleas en vivo:', error);
            hideAllViews();
            document.getElementById('liveFight').classList.add('active');
            showNoLiveFightsMessage();
        }
    }

    function actualizarContadorMenuPeleasEnVivo() {
        setInterval(async () => {
            try {
                const peleasEnVivo = await loadLiveFightsTemp();
                const menuLink = document.querySelector('nav a[onclick*="showFights"]');

                if (menuLink) {
                    if (peleasEnVivo.length > 0) {
                        menuLink.innerHTML = `
                        <i class="fas fa-fire" style="color: #4caf50;"></i>
                        Peleas En Vivo
                        <span style="background: #4caf50; color: white; border-radius: 50%; padding: 2px 6px; font-size: 0.8rem; margin-left: 0.5rem;">
                            ${peleasEnVivo.length}
                        </span>
                    `;
                    } else {
                        menuLink.innerHTML = '<i class="fas fa-fire"></i> Peleas En Vivo';
                    }
                }
            } catch (error) {
                console.error('Error actualizando contador del men√∫:', error);
            }
        }, 30000); // Cada 30 segundos
    }

    function debugRapido() {
        console.log('üîß DEBUG R√ÅPIDO:');
        console.log('Usuario:', currentUser ? `${currentUser.nombre} (${currentUser.rol})` : 'No logueado');
        console.log('Vista actual:',
            document.querySelector('.dashboard.active') ? 'Dashboard' :
                document.querySelector('.live-fight.active') ? 'Peleas en vivo' : 'Desconocida'
        );

        loadLiveFightsTemp().then(peleas => {
            console.log(`Peleas en vivo detectadas: ${peleas.length}`);
            if (peleas.length > 0) {
                console.log('IDs:', peleas.map(p => p.id));
                console.log('Fechas:', peleas.map(p => parseFechaSafe(p.fecha)?.toISOString()));
            }
        });
    }

    document.addEventListener('DOMContentLoaded', function() {
        // Esperar a que se complete la carga inicial
        setTimeout(() => {
            if (currentUser) {
                actualizarEstadisticasEnTiempoReal();
            }
        }, 5000);
    });

    document.addEventListener('DOMContentLoaded', function() {
        // Actualizar el men√∫ para usar la funci√≥n corregida
        setTimeout(() => {
            updateMenuToUseCorrectFunction();

            // Solo iniciar auto-actualizaci√≥n si hay usuario logueado
            if (currentUser) {
                actualizarContadorMenuPeleasEnVivo();
            }
        }, 2000);
    });

    async function resetearYProbar() {
        console.log('üîÑ RESETEANDO Y PROBANDO...');

        // Ir al dashboard
        showDashboardSimple();

        // Esperar un poco
        await new Promise(resolve => setTimeout(resolve, 1000));

        // Actualizar datos
        await refreshData();

        // Probar detecci√≥n
        const resultado = await testDeteccionPeleasEnVivo();

        if (resultado && resultado.enVivo > 0) {
            console.log('‚úÖ HAY PELEAS EN VIVO - Probando vista...');
            await showFights();
        } else {
            console.log('‚ùå NO HAY PELEAS EN VIVO - ¬øCrear una?');
            console.log('üí° Ejecuta: crearPeleaAhoraMismo()');
        }
    }

    function calcularTotales(estadisticas) {
        return {
            golpes: estadisticas.reduce((sum, s) => sum + (s.golpesConectados || 0), 0),
            derribos: estadisticas.reduce((sum, s) => sum + (s.derribos || 0), 0),
            controlJaula: estadisticas.reduce((sum, s) => sum + (s.controlJaulaSegundos || 0), 0),
            round: estadisticas.length > 0 ? Math.max(...estadisticas.map(s => s.round || 1)) : 1
        };
    }

    function updateStatsDisplay(totalesAzul, totalesRojo) {
        try {
            // Verificar que los elementos existen antes de actualizar
            const elements = {
                blueStrikes: document.querySelector('.stat-row:nth-child(1) .stat-blue'),
                redStrikes: document.querySelector('.stat-row:nth-child(1) .stat-red'),
                blueTakedowns: document.querySelector('.stat-row:nth-child(2) .stat-blue'),
                redTakedowns: document.querySelector('.stat-row:nth-child(2) .stat-red'),
                blueCageControl: document.querySelector('.stat-row:nth-child(3) .stat-blue'),
                redCageControl: document.querySelector('.stat-row:nth-child(3) .stat-red'),
                fightStatus: document.querySelector('.fight-status')
            };

            // Actualizar solo si los elementos existen
            if (elements.blueStrikes) elements.blueStrikes.textContent = totalesAzul.golpes;
            if (elements.redStrikes) elements.redStrikes.textContent = totalesRojo.golpes;
            if (elements.blueTakedowns) elements.blueTakedowns.textContent = totalesAzul.derribos;
            if (elements.redTakedowns) elements.redTakedowns.textContent = totalesRojo.derribos;
            if (elements.blueCageControl) elements.blueCageControl.textContent = formatTime(totalesAzul.controlJaula);
            if (elements.redCageControl) elements.redCageControl.textContent = formatTime(totalesRojo.controlJaula);

            // Actualizar round actual
            const currentRound = Math.max(totalesAzul.round, totalesRojo.round);
            if (elements.fightStatus) {
                elements.fightStatus.textContent = `üî¥ EN VIVO - Round ${currentRound}`;
            }

            console.log('‚úÖ Estad√≠sticas actualizadas en la UI');
        } catch (error) {
            console.error('‚ùå Error actualizando display de estad√≠sticas:', error);
        }
    }

    async function loadProbabilities(peleaId, luchadorAzulId, luchadorRojoId) {
        try {
            const probResponse = await fetch(`${API_BASE}/probabilidades`, {
                headers: {
                    'Authorization': `Basic ${currentUser.credentials}`,
                    'Content-Type': 'application/json'
                }
            });

            if (probResponse.ok) {
                const todasProbabilidades = await probResponse.json();

                // Filtrar probabilidades de esta pelea
                const probAzul = todasProbabilidades
                    .filter(p => p.peleaId === peleaId && p.luchadorId === luchadorAzulId)
                    .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))[0];

                const probRojo = todasProbabilidades
                    .filter(p => p.peleaId === peleaId && p.luchadorId === luchadorRojoId)
                    .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))[0];

                let blueProbability = 50;
                let redProbability = 50;

                if (probAzul && probRojo) {
                    blueProbability = Math.round(probAzul.probabilidad);
                    redProbability = Math.round(probRojo.probabilidad);
                } else {
                    // Si no hay probabilidades, calcular basadas en estad√≠sticas
                    const statsResponse = await fetch(`${API_BASE}/estadisticas`, {
                        headers: {
                            'Authorization': `Basic ${currentUser.credentials}`,
                            'Content-Type': 'application/json'
                        }
                    });

                    if (statsResponse.ok) {
                        const stats = await statsResponse.json();
                        const statsAzul = stats.filter(s => s.peleaId === peleaId && s.luchadorId === luchadorAzulId);
                        const statsRojo = stats.filter(s => s.peleaId === peleaId && s.luchadorId === luchadorRojoId);

                        const totalesAzul = calcularTotales(statsAzul);
                        const totalesRojo = calcularTotales(statsRojo);

                        // C√°lculo simple de probabilidad basado en rendimiento
                        const scoreAzul = totalesAzul.golpes + (totalesAzul.derribos * 5) + (totalesAzul.controlJaula / 60);
                        const scoreRojo = totalesRojo.golpes + (totalesRojo.derribos * 5) + (totalesRojo.controlJaula / 60);
                        const total = scoreAzul + scoreRojo;

                        if (total > 0) {
                            blueProbability = Math.round((scoreAzul / total) * 100);
                            redProbability = 100 - blueProbability;
                        }
                    }
                }

                // Actualizar UI
                document.querySelector('.prob-values .stat-blue').textContent = `${blueProbability}%`;
                document.querySelector('.prob-values .stat-red').textContent = `${redProbability}%`;
                document.querySelector('.prob-blue').style.width = `${blueProbability}%`;
                document.querySelector('.prob-red').style.width = `${redProbability}%`;
            }
        } catch (error) {
            console.error('Error cargando probabilidades:', error);
        }
    }

    async function loadLiveFightsTemp() {
        try {
            console.log('üî¥ Obteniendo peleas en vivo (m√©todo temporal con fechas seguras)...');

            const response = await authenticatedFetch(`${API_BASE}/peleas`);

            if (response.ok) {
                const todasLasPeleas = await response.json();
                const ahora = new Date();

                console.log('üïê Hora actual del cliente:', ahora.toISOString());
                console.log('üìã Total peleas recibidas:', todasLasPeleas.length);

                // CORREGIDO: Filtrar con l√≥gica m√°s clara
                const peleasEnVivo = [];

                for (const pelea of todasLasPeleas) {
                    console.log(`\nüìä Analizando pelea ${pelea.id}:`);
                    console.log(`  - Finalizada: ${pelea.finalizada}`);
                    console.log(`  - Fecha string: ${pelea.fecha}`);

                    // Si est√° finalizada, no puede estar en vivo
                    if (pelea.finalizada) {
                        console.log(`  ‚ùå Descartada: ya finalizada`);
                        continue;
                    }

                    // Parsear fecha de manera segura
                    const fechaPelea = parseFechaSafe(pelea.fecha);
                    if (!fechaPelea) {
                        console.log(`  ‚ùå Descartada: fecha inv√°lida`);
                        continue;
                    }

                    console.log(`  - Fecha parseada: ${fechaPelea.toISOString()}`);

                    const diferenciaMs = ahora.getTime() - fechaPelea.getTime();
                    const diferenciaMinutos = diferenciaMs / (1000 * 60);
                    const estaEnVivo = diferenciaMs >= 0; // La pelea ya empez√≥

                    console.log(`  - Diferencia: ${diferenciaMinutos.toFixed(1)} minutos`);
                    console.log(`  - ¬øEst√° en vivo?: ${estaEnVivo ? 'S√ç' : 'NO'}`);

                    if (estaEnVivo) {
                        console.log(`  ‚úÖ AGREGADA a peleas en vivo`);
                        peleasEnVivo.push(pelea);
                    } else {
                        console.log(`  ‚ùå Descartada: a√∫n no empez√≥`);
                    }
                }

                console.log(`\nüìä RESUMEN FINAL:`);
                console.log(`  - Total peleas: ${todasLasPeleas.length}`);
                console.log(`  - En vivo: ${peleasEnVivo.length}`);

                if (peleasEnVivo.length > 0) {
                    console.log('üî¥ PELEAS EN VIVO DETECTADAS:');
                    peleasEnVivo.forEach((pelea, index) => {
                        const fechaPelea = parseFechaSafe(pelea.fecha);
                        console.log(`  ${index + 1}. ID: ${pelea.id}, Fecha: ${fechaPelea ? fechaPelea.toISOString() : 'INV√ÅLIDA'}`);
                    });
                }

                return peleasEnVivo;
            } else {
                throw new Error(`Error ${response.status}: ${response.statusText}`);
            }
        } catch (error) {
            console.error('‚ùå Error cargando peleas en vivo:', error);
            return [];
        }
    }

    async function loadFinishedFightsTemp() {
        try {
            console.log('üèÅ Obteniendo peleas finalizadas (m√©todo temporal)...');

            const response = await authenticatedFetch(`${API_BASE}/peleas`);

            if (response.ok) {
                const todasLasPeleas = await response.json();

                const peleasFinalizadas = todasLasPeleas.filter(pelea => pelea.finalizada);

                console.log(`üìä De ${todasLasPeleas.length} peleas, ${peleasFinalizadas.length} est√°n finalizadas`);
                return peleasFinalizadas;
            } else {
                throw new Error(`Error ${response.status}: ${response.statusText}`);
            }
        } catch (error) {
            console.error('‚ùå Error cargando peleas finalizadas:', error);
            return [];
        }
    }

    // Funci√≥n temporal para obtener peleas de un evento
    async function loadFightsForEventTemp(eventoId) {
        try {
            console.log(`üîç Cargando peleas para evento ${eventoId} (m√©todo temporal)...`);

            const response = await authenticatedFetch(`${API_BASE}/peleas`);

            if (response.ok) {
                const todasLasPeleas = await response.json();

                const peleasDelEvento = todasLasPeleas.filter(pelea => pelea.eventoId === eventoId);

                console.log(`üìä Encontradas ${peleasDelEvento.length} peleas para evento ${eventoId}`);
                return peleasDelEvento;
            } else {
                throw new Error(`Error ${response.status}: ${response.statusText}`);
            }
        } catch (error) {
            console.error('‚ùå Error cargando peleas del evento:', error);
            return [];
        }
    }

    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    function hideAllViews() {
        document.getElementById('dashboard').classList.remove('active');
        document.getElementById('liveFight').classList.remove('active');
    }

    async function loadDashboardData() {
        if (!currentUser) return;

        try {
            // Load stats
            await Promise.all([
                loadEvents(),
                loadFighters(),
                loadStats()
            ]);
        } catch (error) {
            console.error('Error loading dashboard data:', error);
            showToast('Error cargando datos', 'error');
        }
    }

    async function loadEvents() {
        try {
            const response = await fetch(`${API_BASE}/eventos`, {
                headers: {
                    'Authorization': `Basic ${currentUser.credentials}`,
                    'Content-Type': 'application/json'
                }
            });

            if (response.ok) {
                const eventos = await response.json();
                document.getElementById('totalEvents').textContent = eventos.length;
                renderEvents(eventos);
            } else {
                throw new Error('Error cargando eventos');
            }
        } catch (error) {
            console.error('Error loading events:', error);
            document.getElementById('totalEvents').textContent = '0';
            renderEvents([]);
        }
    }

    async function loadFighters() {
        try {
            const response = await fetch(`${API_BASE}/luchadores`, {
                headers: {
                    'Authorization': `Basic ${currentUser.credentials}`,
                    'Content-Type': 'application/json'
                }
            });

            if (response.ok) {
                const luchadores = await response.json();
                document.getElementById('totalFighters').textContent = luchadores.length;
            } else {
                throw new Error('Error cargando luchadores');
            }
        } catch (error) {
            console.error('Error loading fighters:', error);
            document.getElementById('totalFighters').textContent = '0';
        }
    }

    async function loadStats() {
        try {
            console.log('üìä Cargando estad√≠sticas con detecci√≥n corregida...');

            // Obtener todas las peleas
            const response = await authenticatedFetch(`${API_BASE}/peleas`);
            if (!response.ok) {
                throw new Error('Error obteniendo peleas');
            }

            const todasLasPeleas = await response.json();
            const clasificadas = clasificarPeleas(todasLasPeleas);

            console.log('üìä Estad√≠sticas calculadas:');
            console.log(`  - Total peleas: ${todasLasPeleas.length}`);
            console.log(`  - En vivo: ${clasificadas.enVivo.length}`);
            console.log(`  - Futuras: ${clasificadas.futuras.length}`);
            console.log(`  - Finalizadas: ${clasificadas.finalizadas.length}`);

            // Actualizar UI
            document.getElementById('liveFights').textContent = clasificadas.enVivo.length;
            document.getElementById('completedFights').textContent = clasificadas.finalizadas.length;

            // A√±adir animaci√≥n si hay peleas en vivo
            const liveFightsElement = document.getElementById('liveFights');
            if (clasificadas.enVivo.length > 0) {
                liveFightsElement.style.color = '#4caf50';
                liveFightsElement.style.fontWeight = 'bold';
                liveFightsElement.parentElement.classList.add('updating');
                setTimeout(() => liveFightsElement.parentElement.classList.remove('updating'), 500);
            } else {
                liveFightsElement.style.color = '#666';
                liveFightsElement.style.fontWeight = 'normal';
            }

        } catch (error) {
            console.error('‚ùå Error loading fight stats:', error);
            document.getElementById('liveFights').textContent = '0';
            document.getElementById('completedFights').textContent = '0';
        }
    }

    function renderEvents(eventos) {
        const eventsGrid = document.getElementById('eventsGrid');

        if (eventos.length === 0) {
            eventsGrid.innerHTML = `
                    <div style="grid-column: 1/-1; text-align: center; padding: 3rem; color: #cccccc;">
                        <i class="fas fa-calendar-times" style="font-size: 3rem; margin-bottom: 1rem; color: #666;"></i>
                        <h3>No hay eventos disponibles</h3>
                        <p>Crea tu primer evento para comenzar</p>
                        <button class="btn" onclick="createEvent()" style="margin-top: 1rem;">
                            <i class="fas fa-plus"></i> Crear Evento
                        </button>
                    </div>
                `;
            return;
        }

        eventsGrid.innerHTML = eventos.map(evento => `
                <div class="event-card">
                    <div class="event-header">
                        <h3>${evento.nombre}</h3>
                        <div class="event-date">
                            <i class="fas fa-calendar"></i>
                            ${formatDate(evento.fecha)}
                        </div>
                    </div>
                    <div class="event-body">
                        <div class="event-location">
                            <i class="fas fa-map-marker-alt"></i>
                            ${evento.ubicacion || 'Ubicaci√≥n por definir'}
                        </div>
                        <div class="fights-preview">
                            <h4><i class="fas fa-fist-raised"></i> Peleas</h4>
                            <div class="fight-item">
                                <div class="fighters">
                                    <span class="fighter">Cargando peleas...</span>
                                </div>
                                <span class="fight-status status-upcoming">Pr√≥ximamente</span>
                            </div>
                        </div>
                        <div class="event-actions">
                            <button class="btn" onclick="viewEvent(${evento.id})">
                                <i class="fas fa-eye"></i> Ver Evento
                            </button>
                            <button class="btn btn-secondary" onclick="editEvent(${evento.id})">
                                <i class="fas fa-edit"></i> Editar
                            </button>
                        </div>
                    </div>
                </div>
            `).join('');
    }

    function formatDate(dateString) {
        const date = new Date(dateString);
        return date.toLocaleDateString('es-ES', {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        });
    }

    function viewEvent(eventId) {
        showToast(`Viendo evento ID: ${eventId}`, 'success');
        // Here you would load the specific event details
    }

    function editEvent(eventId) {
        if (currentUser.rol !== 'admin') {
            showToast('Solo los administradores pueden editar eventos', 'error');
            return;
        }
        showToast(`Editando evento ID: ${eventId}`, 'success');
        // Here you would open an edit modal or form
    }

    function createEvent() {
        if (currentUser.rol !== 'admin') {
            showToast('Solo los administradores pueden crear eventos', 'error');
            return;
        }

        const name = prompt('Nombre del evento:');
        const location = prompt('Ubicaci√≥n:');
        const date = prompt('Fecha (YYYY-MM-DD):');

        if (name && location && date) {
            createEventAPI(name, location, date);
        }
    }

    async function createEventAPI(nombre, ubicacion, fecha) {
        try {
            const response = await fetch(`${API_BASE}/eventos`, {
                method: 'POST',
                headers: {
                    'Authorization': `Basic ${currentUser.credentials}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    nombre: nombre,
                    ubicacion: ubicacion,
                    fecha: fecha
                })
            });

            if (response.ok) {
                showToast('Evento creado exitosamente', 'success');
                loadEvents(); // Reload events
            } else {
                throw new Error('Error creando evento');
            }
        } catch (error) {
            showToast('Error creando evento', 'error');
        }
    }

    async function reloadLiveFightView() {
        console.log('üîÑ Recargando vista de peleas en vivo completamente...');

        try {
            // Obtener peleas en vivo
            const peleasEnVivo = await loadLiveFightsTemp();

            if (peleasEnVivo.length === 0) {
                console.log('‚ùå No hay peleas en vivo - mostrando mensaje');
                showNoLiveFightsMessage();
                return;
            }

            console.log(`‚úÖ ${peleasEnVivo.length} peleas en vivo encontradas`);

            // Mostrar la primera pelea con la nueva UI
            await displayFightInfo(peleasEnVivo[0]);

            showToast(`Vista recargada - Mostrando pelea ID: ${peleasEnVivo[0].id}`, 'success');

        } catch (error) {
            console.error('‚ùå Error recargando vista:', error);
            showToast('Error recargando vista de peleas en vivo', 'error');
        }
    }

    function refreshData() {
        showToast('Actualizando datos...', 'success');
        loadDashboardData();
    }

    function showToast(message, type = 'success') {
        // Remove existing toasts
        const existingToast = document.querySelector('.toast');
        if (existingToast) {
            existingToast.remove();
        }

        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.textContent = message;

        document.body.appendChild(toast);

        // Show toast
        setTimeout(() => toast.classList.add('show'), 100);

        // Hide toast after 3 seconds
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => toast.remove(), 300);
        }, 3000);
    }

    // WebSocket Live Fight Tracker
    class LiveFightWebSocket {
        constructor() {
            this.ws = null;
            this.reconnectAttempts = 0;
            this.maxReconnectAttempts = 3; // Reducido para evitar spam
            this.reconnectDelay = 3000;    // Aumentado el delay
            this.isConnected = false;
            this.shouldReconnect = true;   // Flag para controlar reconexiones
        }

        connect() {
            // No intentar conectar si no hay peleas en vivo
            if (!this.shouldReconnect) {
                console.log('üö´ WebSocket: Conexi√≥n deshabilitada');
                return;
            }

            try {
                console.log('üîå Intentando conectar WebSocket...');
                this.ws = new WebSocket('ws://localhost:8080/live-fight');

                this.ws.onopen = (event) => {
                    console.log('‚úÖ WebSocket conectado');
                    this.isConnected = true;
                    this.reconnectAttempts = 0;
                    // Solo mostrar √©xito en modo debug
                    // this.showConnectionStatus('Conectado en tiempo real', 'success');
                };

                this.ws.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        this.handleMessage(message);
                    } catch (error) {
                        console.error('‚ùå Error parseando mensaje WebSocket:', error);
                    }
                };

                this.ws.onclose = (event) => {
                    console.log('üîå WebSocket desconectado:', event.code, event.reason);
                    this.isConnected = false;

                    // Solo intentar reconectar si es necesario y no hemos excedido los intentos
                    if (this.shouldReconnect && this.reconnectAttempts < this.maxReconnectAttempts) {
                        this.attemptReconnect();
                    } else {
                        console.log('üõë WebSocket: No se reintentar√° la conexi√≥n');
                    }
                };

                this.ws.onerror = (error) => {
                    console.error('‚ùå Error WebSocket:', error);
                    // No mostrar mensaje de error al usuario por cada fallo
                };

            } catch (error) {
                console.error('‚ùå Error creando WebSocket:', error);
                this.attemptReconnect();
            }
        }

        handleMessage(message) {
            console.log('üì® Mensaje WebSocket recibido:', message);

            switch (message.type) {
                case 'welcome':
                    console.log('üëã WebSocket: Bienvenida recibida');
                    break;

                case 'fight-stats':
                    console.log('üìä WebSocket: Estad√≠sticas de pelea recibidas');
                    // Por ahora solo logear, no actualizar autom√°ticamente
                    break;

                case 'no-fights':
                    console.log('üì≠ WebSocket: No hay peleas en vivo');
                    break;

                default:
                    console.log('‚ùì WebSocket: Mensaje no reconocido:', message);
            }
        }

        attemptReconnect() {
            if (!this.shouldReconnect || this.reconnectAttempts >= this.maxReconnectAttempts) {
                console.log('üõë WebSocket: M√°ximo de reintentos alcanzado');
                return;
            }

            this.reconnectAttempts++;
            console.log(`üîÑ WebSocket: Reintento ${this.reconnectAttempts}/${this.maxReconnectAttempts} en ${this.reconnectDelay}ms...`);

            setTimeout(() => {
                if (this.shouldReconnect) {
                    this.connect();
                }
            }, this.reconnectDelay);

            // Aumentar el delay para el pr√≥ximo intento
            this.reconnectDelay = Math.min(this.reconnectDelay * 1.5, 10000);
        }

        disconnect() {
            console.log('üîå Desconectando WebSocket...');
            this.shouldReconnect = false;

            if (this.ws) {
                this.ws.close();
                this.ws = null;
            }

            this.isConnected = false;
            this.reconnectAttempts = 0;
        }

        // M√©todo para reactivar conexiones
        enable() {
            this.shouldReconnect = true;
            this.reconnectAttempts = 0;
            this.reconnectDelay = 3000;
        }
    }



    // Desconectar cuando se cierra la p√°gina
    window.addEventListener('beforeunload', () => {
        if (liveWebSocket) {
            liveWebSocket.disconnect();
        }
    });

    // Funci√≥n para forzar actualizaci√≥n manual
    function forceUpdate() {
        if (liveWebSocket && liveWebSocket.isConnected) {
            liveWebSocket.requestUpdate();
            showToast('Solicitando actualizaci√≥n...', 'success');
        } else {
            showToast('No hay conexi√≥n WebSocket', 'error');
        }
    }

    function determinarEstadoPeleaReal(pelea) {
        if (pelea.finalizada) {
            return 'FINALIZADA';
        }

        const fechaPelea = parseFechaSafe(pelea.fecha);
        if (!fechaPelea) {
            console.error('‚ùå No se pudo parsear fecha de pelea:', pelea);
            return 'ERROR';
        }

        const ahora = new Date();
        const diferenciaMs = ahora.getTime() - fechaPelea.getTime();
        const diferenciaMinutos = diferenciaMs / (1000 * 60);

        console.log(`üïê An√°lisis de fecha para pelea ${pelea.id}:
        Pelea: ${fechaPelea.toISOString()}
        Ahora:  ${ahora.toISOString()}
        Diferencia: ${diferenciaMinutos.toFixed(1)} minutos
        En vivo: ${diferenciaMs >= 0 ? 'S√ç' : 'NO'}`);

        if (fechaPelea <= ahora) {
            return 'EN_VIVO';
        } else {
            return 'FUTURA';
        }
    }


    function getFightStatusClass(pelea) {
        const estado = determinarEstadoPeleaReal(pelea);

        switch (estado) {
            case 'FINALIZADA':
                return 'status-finished';
            case 'EN_VIVO':
                return 'status-live';
            case 'FUTURA':
                return 'status-upcoming';
            default:
                return 'status-upcoming';
        }
    }

    function getFightStatusText(pelea) {
        const estado = determinarEstadoPeleaReal(pelea);

        switch (estado) {
            case 'FINALIZADA':
                return 'Finalizada';
            case 'EN_VIVO':
                return 'üî¥ En Vivo';
            case 'FUTURA':
                return 'Pr√≥ximamente';
            default:
                return 'Pr√≥ximamente';
        }
    }

    document.addEventListener('DOMContentLoaded', function() {
        // Sobrescribir funciones antiguas con las nuevas
        setTimeout(() => {
            console.log('üîÑ Actualizando funciones a versiones corregidas...');

            // Reemplazar showNoLiveFightsMessage
            window.showNoLiveFightsMessage = showNoLiveFightsMessageUpdated;

            console.log('‚úÖ Funciones actualizadas correctamente');
        }, 1000);
    });

    async function testearFlujoCompleto() {
        console.log('üß™ INICIANDO TEST COMPLETO DEL FLUJO');
        console.log('='.repeat(50));

        try {
            // Paso 1: Verificar peleas en vivo
            console.log('\n1Ô∏è‚É£ Verificando peleas en vivo...');
            const peleasEnVivo = await loadLiveFightsTemp();
            console.log(`‚úÖ Detectadas ${peleasEnVivo.length} peleas en vivo`);

            if (peleasEnVivo.length === 0) {
                console.log('‚ùå No hay peleas en vivo');
                console.log('üí° Ejecutando: crearPeleaAhoraMismo()');
                await crearPeleaAhoraMismo();

                // Esperar y verificar de nuevo
                await new Promise(resolve => setTimeout(resolve, 2000));
                const nuevasPeleas = await loadLiveFightsTemp();
                console.log(`‚úÖ Despu√©s de crear: ${nuevasPeleas.length} peleas en vivo`);

                if (nuevasPeleas.length === 0) {
                    throw new Error('No se pudo crear pelea en vivo');
                }
            }

            // Paso 2: Probar vista de peleas en vivo
            console.log('\n2Ô∏è‚É£ Probando vista de peleas en vivo...');
            await showFights();
            console.log('‚úÖ Vista de peleas en vivo cargada');

            // Paso 3: Verificar que se muestren datos reales
            console.log('\n3Ô∏è‚É£ Verificando datos en la UI...');
            setTimeout(() => {
                const elementos = {
                    blueStrikes: document.getElementById('blueStrikes'),
                    redStrikes: document.getElementById('redStrikes'),
                    currentRound: document.getElementById('currentRound')
                };

                let elementosEncontrados = 0;
                Object.keys(elementos).forEach(key => {
                    if (elementos[key]) {
                        elementosEncontrados++;
                        console.log(`  ‚úÖ ${key}: ${elementos[key].textContent}`);
                    } else {
                        console.log(`  ‚ùå ${key}: no encontrado`);
                    }
                });

                if (elementosEncontrados === 3) {
                    console.log('‚úÖ Todos los elementos de UI encontrados');
                } else {
                    console.log(`‚ö†Ô∏è Solo ${elementosEncontrados}/3 elementos encontrados`);
                }
            }, 2000);

            console.log('\nüéâ TEST COMPLETO FINALIZADO');
            return true;

        } catch (error) {
            console.error('‚ùå Error en test completo:', error);
            return false;
        }
    }

    async function setupPeleaConDatos() {
        console.log('üõ†Ô∏è SETUP R√ÅPIDO DE PELEA CON DATOS');

        try {
            // Obtener peleas en vivo
            const peleasEnVivo = await loadLiveFightsTemp();

            if (peleasEnVivo.length === 0) {
                console.log('üìù Creando pelea en vivo...');
                await crearPeleaAhoraMismo();
                await new Promise(resolve => setTimeout(resolve, 2000));
            }

            // Obtener la pelea actualizada
            const peleasActualizadas = await loadLiveFightsTemp();
            if (peleasActualizadas.length === 0) {
                throw new Error('No se pudo crear pelea');
            }

            const pelea = peleasActualizadas[0];
            console.log(`ü•ä Usando pelea ID: ${pelea.id}`);

            // Completar setup con estad√≠sticas y probabilidades
            console.log('üìä Creando estad√≠sticas y probabilidades...');
            await completarSetupPeleaEnVivo(pelea.id, pelea.luchadorAzulId, pelea.luchadorRojoId);

            // Mostrar la pelea
            console.log('üëÄ Mostrando pelea en vivo...');
            await showFights();

            console.log('‚úÖ Setup completo finalizado');
            showToast('Setup de pelea con datos completado', 'success');

        } catch (error) {
            console.error('‚ùå Error en setup:', error);
            showToast('Error en setup: ' + error.message, 'error');
        }
    }

    async function agregarGolpes(peleaId, luchadorId, cantidadGolpes = 5) {
        if (!currentUser || currentUser.rol !== 'admin') {
            showToast('Solo los administradores pueden agregar golpes', 'error');
            return;
        }

        try {
            console.log(`üëä Agregando ${cantidadGolpes} golpes para luchador ${luchadorId}...`);

            // Obtener estad√≠sticas actuales
            const statsResponse = await authenticatedFetch(`${API_BASE}/estadisticas`);
            const todasStats = await statsResponse.json();

            // Encontrar la √∫ltima estad√≠stica de este luchador en esta pelea
            const statsLuchador = todasStats
                .filter(s => s.peleaId === peleaId && s.luchadorId === luchadorId)
                .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))[0];

            if (!statsLuchador) {
                throw new Error('No se encontraron estad√≠sticas para este luchador');
            }

            // Crear nueva estad√≠stica con golpes adicionales
            const nuevaStat = {
                peleaId: peleaId,
                luchadorId: luchadorId,
                round: statsLuchador.round,
                golpesConectados: parseInt(statsLuchador.golpesConectados) + cantidadGolpes,
                derribos: statsLuchador.derribos,
                controlJaulaSegundos: statsLuchador.controlJaulaSegundos,
                timestamp: new Date().toISOString()
            };

            console.log('üìä Nueva estad√≠stica:', nuevaStat);

            const response = await authenticatedFetch(`${API_BASE}/estadisticas`, {
                method: 'POST',
                body: JSON.stringify(nuevaStat)
            });

            if (response.ok) {
                console.log(`‚úÖ ${cantidadGolpes} golpes agregados`);
                showToast(`+${cantidadGolpes} golpes agregados`, 'success');
            } else {
                throw new Error('Error agregando golpes');
            }

        } catch (error) {
            console.error('‚ùå Error agregando golpes:', error);
            showToast('Error agregando golpes: ' + error.message, 'error');
        }
    }

    async function agregarDerribo(peleaId, luchadorId) {
        if (!currentUser || currentUser.rol !== 'admin') {
            showToast('Solo los administradores pueden agregar derribos', 'error');
            return;
        }

        try {
            console.log(`ü§º Agregando derribo para luchador ${luchadorId}...`);

            // Obtener estad√≠sticas actuales
            const statsResponse = await authenticatedFetch(`${API_BASE}/estadisticas`);
            const todasStats = await statsResponse.json();

            const statsLuchador = todasStats
                .filter(s => s.peleaId === peleaId && s.luchadorId === luchadorId)
                .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))[0];

            if (!statsLuchador) {
                throw new Error('No se encontraron estad√≠sticas para este luchador');
            }

            // Crear nueva estad√≠stica con derribo adicional
            const nuevaStat = {
                peleaId: peleaId,
                luchadorId: luchadorId,
                round: statsLuchador.round,
                golpesConectados: statsLuchador.golpesConectados,
                derribos: parseInt(statsLuchador.derribos) + 1,
                controlJaulaSegundos: parseInt(statsLuchador.controlJaulaSegundos) + 30, // +30s control por derribo
                timestamp: new Date().toISOString()
            };

            const response = await authenticatedFetch(`${API_BASE}/estadisticas`, {
                method: 'POST',
                body: JSON.stringify(nuevaStat)
            });

            if (response.ok) {
                console.log('‚úÖ Derribo agregado');
                showToast('¬°Derribo agregado! (+30s control)', 'success');
            } else {
                throw new Error('Error agregando derribo');
            }

        } catch (error) {
            console.error('‚ùå Error agregando derribo:', error);
            showToast('Error agregando derribo: ' + error.message, 'error');
        }
    }

    async function actualizarProbabilidades(peleaId, luchadorAzulId, luchadorRojoId, probAzul, probRojo) {
        if (!currentUser || currentUser.rol !== 'admin') {
            showToast('Solo los administradores pueden actualizar probabilidades', 'error');
            return;
        }

        if (probAzul + probRojo !== 100) {
            showToast('Las probabilidades deben sumar 100%', 'error');
            return;
        }

        try {
            console.log(`üéØ Actualizando probabilidades: Azul ${probAzul}%, Rojo ${probRojo}%`);

            const probAzulData = {
                peleaId: peleaId,
                luchadorId: luchadorAzulId,
                probabilidad: probAzul,
                timestamp: new Date().toISOString()
            };

            const probRojoData = {
                peleaId: peleaId,
                luchadorId: luchadorRojoId,
                probabilidad: probRojo,
                timestamp: new Date().toISOString()
            };

            const responses = await Promise.all([
                authenticatedFetch(`${API_BASE}/probabilidades`, {
                    method: 'POST',
                    body: JSON.stringify(probAzulData)
                }),
                authenticatedFetch(`${API_BASE}/probabilidades`, {
                    method: 'POST',
                    body: JSON.stringify(probRojoData)
                })
            ]);

            if (responses[0].ok && responses[1].ok) {
                console.log('‚úÖ Probabilidades actualizadas');
                showToast(`Probabilidades: ${probAzul}% vs ${probRojo}%`, 'success');
            } else {
                throw new Error('Error actualizando probabilidades');
            }

        } catch (error) {
            console.error('‚ùå Error actualizando probabilidades:', error);
            showToast('Error actualizando probabilidades: ' + error.message, 'error');
        }
    }
</script>
</body>
</html>